# 算法在计算中的作用

## 算法

算法是任何良定义的计算过程，该过程取某个值或值的集合作为<u>输入</u>并产生某个值或值的集合作为<u>输出</u>。

## 伪代码约定

- 缩进表示块结构
- while、for与repeat-until等循环结构以及if-else等条件结构与C、C++、Java、Python和Pascal中的那些结构具有类似的解释。
- 符号“//”表示该行后面部分是个注释
- i = j = e 等价于 j = e; i = j
- 变量是局部于给定过程的。无显式说明，不使用全局变量
- 数据元素通过“数组名[下标]”这样的形式访问
- 复合数据通常被组织成对象，对象又由属性组成。赋值y = x 后，x和y指向相同的对象。
- 按值把参数传递给过程，被调用过程接受其参数自身的副本
- 一个return语句立即将控制返回到调用过程的调用点
- 布尔运算符“and”和“or”都是短路的。
- 关键词error表示因为已被调用的过程情况不对而出现了一个错误。调用过程负责处理该错误，所以我们不用说明将采取什么行动。



# 算法基础

## 问题引入

**输入:** n个数的一个序列
$$
< a_1, a_2, ..., a_n >
$$
**输出：**输入序列的一个排列
$$
<a_1', a_2', ..., a_n'>，满足a_1'≤a_2'≤...≤a_n'
$$

### 插入排序

```
INSERTION-SORT(A):
	for j = 2 to A.length
		key = A[j]
		// Insert A[j] into the sorted sequence A[1 .. j - 1]
		i = j - 1
		while i > 0 and A[i] > key
			A[i + 1] = A[i]
			i = i - 1
		A[i + 1] = key
```

**Example:**

![1682348690689](.\Image\插入排序.png)



**循环不变式**

初始化：循环的第一次迭代之前，为真

保持：如果循环的某次迭代之前他为真，下次迭代之前它仍然为真

终止：循环终止时，不变式提供一个有用的性质，该性质有助于证明算法是正确的。

## 分析算法

RAM模型：(即random-access machine, RAM)，在RAM模型，指令一条接一条地执行，没有并发操作。

**运行时间**

​	执行的基本操作数或步数。

**输入规模**

​	输入规模的最佳概念依赖于研究的问题。

分析算法只求**最坏情况运行时间**，即对规模为n的任何输入，算法的最长运行时间。

​	![1682348690689](.\Image\最坏情况.png)

**增长量级**

​	只考虑公式中最重要的项，也忽略最重要的项的常系数。



## 设计算法

**分治法**

当算法在结构上递归时，算法一次或多次递归地调用其自身以解决紧密相关的若干子问题。

以上算法遵循分治法的思想：

*将原问题分解为几个规模较小但类似于原问题的子问题，递归的求解这些子问题，然后再合并这些子问题的解来建立原问题的解。*

**分治步骤：**

**分解**原问题为若干子问题，这些子问题是原问题的规模较小的实例。
**解决**这些子问题，递归地求解各子问题。然而，若子问题的规模足够小，则直接求解。
**合并**这些子问题的解成原问题的解。

#### 归并排序

**分解**：分解待排序的n个元素的序列成各具n/2个元素的两个子序列。

**解决**：使用归并排序递归地排序两个子序列。

**合并**：合并两个已排序的子序列以产生已排序的答案。



**算法：**

关键操作是“合并”步骤中两个已排序序列的合并。

MERGE(A, p, q, r)

​	A是一个数组，p、q和r是数组下标，满足 p <= q < r。

​	假设子数组A[p .. q] 和 A[q+1 ..r]都已经排序好

```
MERGE(A, p, q, r)
	n1 = q - p + 1
	n2 = r - q
	let L[1 .. n1 + 1] and R[1 .. n2 + 1] be new arrays
	for i = 1 to n1
		L[i] = A[p + i - 1]
	for j = 1 to n2
		R[j] = A[q + j]
	L[n1 + 1] = 无穷大
	R[n2 + 1] = 无穷大
	i = 1
	j = 1
	for k = p to r
		if L[i] <= R[j]
			A[k] = L[i]
			i = i + 1
		else
			A[k] = R[j]
			j = j + 1
			
MERGE-SORT(A, p, r)
	if p < r
		q = 向下取整((p + r) / 2)
		MERGE-SORT(A, p, q)
		MERGE-SORT(A, q + 1, r)
		MERGE(A, p, q, r)
```

**Example(一次归并):**

![1682348690689](.\Image\归并排序.png)



![1682348690689](.\Image\归并排序2.png)

最坏情况运行时间：

​	![1682348690689](.\Image\归并排序最坏情况.png)





# 函数的增长

## 渐近记号

![1682348690689](.\Image\渐进记号.png)



![1682348690689](.\Image\最坏情况记号.png)

**渐近紧确界**

之后以**ZH**代替

> **ZH**(g(n)) = {f(n): 存在正常量c~1~、c~2~和n~0~，使得对所有n >= n~0~，有0 <= c~1~g(n) <= f(n) <= c~2~g(n)}

解释：

若存在正常量c~1~和c~2~，使得对于足够大的n，函数f(n)能“夹入”c~1~g(n)与c~2~g(n)之间，则f(n)属于集合**ZH**(g(n))。

**ZH**(g(n))要求每个成员f(n) ∈ **ZH**(g(n))均渐近非负，即当n足够大时，f(n)非负。



![1682348690689](.\Image\渐近上界.png)

**渐近上界**

> O(g(n)) = {f(n):存在正常量c和n~0~，使得对所有n >= n~0~，有 0 <= f(n) <= cg(n)}

f(n) = **ZH**(g(n))蕴含着 f(n) = O(g(n))



![1682348690689](.\Image\渐近下界.png)

**渐近下界**

> Ω(g(n)) = {f(n)：存在正常量c和n~0~，使得对所有n>=n~0~，有0 <= cg(n) <= f(n)}
>



![1682348690689](.\Image\非渐近紧确上界.png)

**非渐近紧确上界**

> o(g(n)) = {f(n)：对**任意**正常量c > 0，存在常量n~0~ > 0，使得对所有 n >= n~0~， 有 0 <= f(n) < cg(n)}



![1682348690689](.\Image\非渐近紧确下界.png)

**非渐近紧确下界**

> w(g(n)) = {f(n)：对**任意**正常量c > 0，存在常量n~0~ > 0，使得对所有n >= n~0~，有 0 <= cg(n) < f(n)}



## 标准记号与常用函数

**单调性**

若m <= n蕴涵 f(m) <= f(n)，则函数 f(n)是**单调递增**的。类似地，若m <= n蕴涵f(m) >= f(n)，则函数f(n)是**单调递减**的。若m < n 蕴涵 f(m) < f(n)，则函数 f(n)是**严格递增**的。若m < n蕴涵f(m) > f(n)，则函数f(n)是**严格递减**的。



# 分治策略

递归的求解一个问题，在每层递归中应用如下三个步骤：

**分解**(Divide)步骤将问题划分为一些子问题，子问题的形式与原问题一样，只是规模更小。

**解决**(Conquer)步骤递归地求解出子问题。如果子问题的规模足够小，则停止递归，直接求解。

**合并**(Combine)步骤将子问题的解组合成原问题的解。



递归情况：

​	当子问题足够大，需要递归求解时，称之为递归情况

基本情况：

​	当子问题足够小，不再需要递归时，进入基本情况



## 最大子数组问题

最大化收益率，在某个时刻买入股票，并在未来的某天卖出股票

![1682348690689](.\Image\最大子数组问题.png)

### 使用分治策略的求解方法

假定寻找子数组A[low .. high]的最大子数组。使用分治意味着要将子数组划分为两个规模尽量相等的子数组。找到子数组的中央位置mid，然后考虑求解两个子数组A[low .. mid]和A[mid+1 .. high]。

A[low .. high]的任何连续子数组A[i .. j]所处的位置必然是以下三种情况之一：

- 完全位于子数组A[low .. mid]中，因此 low <= i <= j <= mid
- 完全位于子数组A[mid+1 .. high]中，因此 mid < i <= j <= high
- 跨越了中点，因此low <= i <= mid < j <= high

过程FIND-MAX-CORSSING-SUBARRAY接收数组A和下标low、mid和high为输入，返回一个下标元组划定跨越中点的最大子数组的边界，并返回最大子数组中值的和。

```
FIND-MAX-CROSSING-SUBARRAY(A, low, mid, high)
	// 求出左半部A[low .. mid]的最大子数组
	left-sum = 负无穷大
	sum = 0
	//  
	for i = mid downto low
		sum = sum + A[i]
		if sum > left-sum
			left-sum = sum
			max-left = i
	
	// 求右半部A[mid+1 .. high]的最大子数组
	right-sum = 负无穷大
	sum = 0
	for j = mid + 1 to high
		sum = sum + A[j]
		if sum > right-sum
			right-sum = sum
			max-right = j
	return (max-left, max-right, left-sum + right-sum)
```



求解最大子数组分治算法的伪代码：

```
FIND-MAXIMUM-SUBARRAY(A, low, high) 
	if high == low
		return (low, high, A[low])
	else
		mid = 向下取整((low + high) / 2)
		(left-low, left-high, left-sum) =
			FIND-MAXIMUM-SUBARRAY(A, low, mid)
		(right-low, right-high, right-sum) = 
			FIND-MAXIMUM-SUBARRAY(A, mid + 1, high)
		(cross-low, cross-high, cross-sum) = 
			FIND-MAX-CROSSING-SUBARRAY(A, low, mid, high)
	
		if left-sum >= right-sum and left-sum >= cross-sum
			return (left-low, left-high, left-sum)
		elseif right-sum >= left-sum and right-sum >= cross-sum
			return (right-low, right-high, right-sum)
		else
			return (cross-low, cross-high, cross-sum)		

```

