# 算法在计算中的作用

## 算法

算法是任何良定义的计算过程，该过程取某个值或值的集合作为<u>输入</u>并产生某个值或值的集合作为<u>输出</u>。

## 伪代码约定

- 缩进表示块结构
- while、for与repeat-until等循环结构以及if-else等条件结构与C、C++、Java、Python和Pascal中的那些结构具有类似的解释。
- 符号“//”表示该行后面部分是个注释
- i = j = e 等价于 j = e; i = j
- 变量是局部于给定过程的。无显式说明，不使用全局变量
- 数据元素通过“数组名[下标]”这样的形式访问
- 复合数据通常被组织成对象，对象又由属性组成。赋值y = x 后，x和y指向相同的对象。
- 按值把参数传递给过程，被调用过程接受其参数自身的副本
- 一个return语句立即将控制返回到调用过程的调用点
- 布尔运算符“and”和“or”都是短路的。
- 关键词error表示因为已被调用的过程情况不对而出现了一个错误。调用过程负责处理该错误，所以我们不用说明将采取什么行动。



# 算法基础

## 问题引入

**输入:** n个数的一个序列
$$
< a_1, a_2, ..., a_n >
$$
**输出：**输入序列的一个排列
$$
<a_1', a_2', ..., a_n'>，满足a_1'≤a_2'≤...≤a_n'
$$

### 插入排序

```
INSERTION-SORT(A):
	for j = 2 to A.length
		key = A[j]
		// Insert A[j] into the sorted sequence A[1 .. j - 1]
		i = j - 1
		while i > 0 and A[i] > key
			A[i + 1] = A[i]
			i = i - 1
		A[i + 1] = key
```

**Example:**

![1682348690689](.\Image\插入排序.png)



**循环不变式**

初始化：循环的第一次迭代之前，为真

保持：如果循环的某次迭代之前他为真，下次迭代之前它仍然为真

终止：循环终止时，不变式提供一个有用的性质，该性质有助于证明算法是正确的。

## 分析算法

RAM模型：(即random-access machine, RAM)，在RAM模型，指令一条接一条地执行，没有并发操作。

**运行时间**

​	执行的基本操作数或步数。

**输入规模**

​	输入规模的最佳概念依赖于研究的问题。

分析算法只求**最坏情况运行时间**，即对规模为n的任何输入，算法的最长运行时间。

​	![1682348690689](.\Image\最坏情况.png)

**增长量级**

​	只考虑公式中最重要的项，也忽略最重要的项的常系数。



## 设计算法

**分治法**

当算法在结构上递归时，算法一次或多次递归地调用其自身以解决紧密相关的若干子问题。

以上算法遵循分治法的思想：

*将原问题分解为几个规模较小但类似于原问题的子问题，递归的求解这些子问题，然后再合并这些子问题的解来建立原问题的解。*

**分治步骤：**

**分解**原问题为若干子问题，这些子问题是原问题的规模较小的实例。
**解决**这些子问题，递归地求解各子问题。然而，若子问题的规模足够小，则直接求解。
**合并**这些子问题的解成原问题的解。

#### 归并排序

**分解**：分解待排序的n个元素的序列成各具n/2个元素的两个子序列。

**解决**：使用归并排序递归地排序两个子序列。

**合并**：合并两个已排序的子序列以产生已排序的答案。



**算法：**

关键操作是“合并”步骤中两个已排序序列的合并。

MERGE(A, p, q, r)

​	A是一个数组，p、q和r是数组下标，满足 p <= q < r。

​	假设子数组A[p .. q] 和 A[q+1 ..r]都已经排序好

```
MERGE(A, p, q, r)
	n1 = q - p + 1
	n2 = r - q
	let L[1 .. n1 + 1] and R[1 .. n2 + 1] be new arrays
	for i = 1 to n1
		L[i] = A[p + i - 1]
	for j = 1 to n2
		R[j] = A[q + j]
	L[n1 + 1] = 无穷大
	R[n2 + 1] = 无穷大
	i = 1
	j = 1
	for k = p to r
		if L[i] <= R[j]
			A[k] = L[i]
			i = i + 1
		else
			A[k] = R[j]
			j = j + 1
			
MERGE-SORT(A, p, r)
	if p < r
		q = 向下取整((p + r) / 2)
		MERGE-SORT(A, p, q)
		MERGE-SORT(A, q + 1, r)
		MERGE(A, p, q, r)
```

**Example(一次归并):**

![1682348690689](.\Image\归并排序.png)



![1682348690689](.\Image\归并排序2.png)

最坏情况运行时间：

​	![1682348690689](.\Image\归并排序最坏情况.png)





# 函数的增长

## 渐近记号

![1682348690689](.\Image\渐进记号.png)



![1682348690689](.\Image\最坏情况记号.png)

**渐近紧确界**

之后以**ZH**代替

> **ZH**(g(n)) = {f(n): 存在正常量c~1~、c~2~和n~0~，使得对所有n >= n~0~，有0 <= c~1~g(n) <= f(n) <= c~2~g(n)}

解释：

若存在正常量c~1~和c~2~，使得对于足够大的n，函数f(n)能“夹入”c~1~g(n)与c~2~g(n)之间，则f(n)属于集合**ZH**(g(n))。

**ZH**(g(n))要求每个成员f(n) ∈ **ZH**(g(n))均渐近非负，即当n足够大时，f(n)非负。



![1682348690689](.\Image\渐近上界.png)

**渐近上界**

> O(g(n)) = {f(n):存在正常量c和n~0~，使得对所有n >= n~0~，有 0 <= f(n) <= cg(n)}

f(n) = **ZH**(g(n))蕴含着 f(n) = O(g(n))



![1682348690689](.\Image\渐近下界.png)

**渐近下界**

> Ω(g(n)) = {f(n)：存在正常量c和n~0~，使得对所有n>=n~0~，有0 <= cg(n) <= f(n)}
>



![1682348690689](.\Image\非渐近紧确上界.png)

**非渐近紧确上界**

> o(g(n)) = {f(n)：对**任意**正常量c > 0，存在常量n~0~ > 0，使得对所有 n >= n~0~， 有 0 <= f(n) < cg(n)}



![1682348690689](.\Image\非渐近紧确下界.png)

**非渐近紧确下界**

> w(g(n)) = {f(n)：对**任意**正常量c > 0，存在常量n~0~ > 0，使得对所有n >= n~0~，有 0 <= cg(n) < f(n)}



## 标准记号与常用函数

**单调性**

若m <= n蕴涵 f(m) <= f(n)，则函数 f(n)是**单调递增**的。类似地，若m <= n蕴涵f(m) >= f(n)，则函数f(n)是**单调递减**的。若m < n 蕴涵 f(m) < f(n)，则函数 f(n)是**严格递增**的。若m < n蕴涵f(m) > f(n)，则函数f(n)是**严格递减**的。



# 分治策略

递归的求解一个问题，在每层递归中应用如下三个步骤：

**分解**(Divide)步骤将问题划分为一些子问题，子问题的形式与原问题一样，只是规模更小。

**解决**(Conquer)步骤递归地求解出子问题。如果子问题的规模足够小，则停止递归，直接求解。

**合并**(Combine)步骤将子问题的解组合成原问题的解。



递归情况：

​	当子问题足够大，需要递归求解时，称之为递归情况

基本情况：

​	当子问题足够小，不再需要递归时，进入基本情况



## 最大子数组问题

最大化收益率，在某个时刻买入股票，并在未来的某天卖出股票

![1682348690689](.\Image\最大子数组问题.png)

### 使用分治策略的求解方法

假定寻找子数组A[low .. high]的最大子数组。使用分治意味着要将子数组划分为两个规模尽量相等的子数组。找到子数组的中央位置mid，然后考虑求解两个子数组A[low .. mid]和A[mid+1 .. high]。

A[low .. high]的任何连续子数组A[i .. j]所处的位置必然是以下三种情况之一：

- 完全位于子数组A[low .. mid]中，因此 low <= i <= j <= mid
- 完全位于子数组A[mid+1 .. high]中，因此 mid < i <= j <= high
- 跨越了中点，因此low <= i <= mid < j <= high

过程FIND-MAX-CORSSING-SUBARRAY接收数组A和下标low、mid和high为输入，返回一个下标元组划定跨越中点的最大子数组的边界，并返回最大子数组中值的和。

```
FIND-MAX-CROSSING-SUBARRAY(A, low, mid, high)
	// 求出左半部A[low .. mid]的最大子数组
	left-sum = 负无穷大
	sum = 0
	//  
	for i = mid downto low
		sum = sum + A[i]
		if sum > left-sum
			left-sum = sum
			max-left = i
	
	// 求右半部A[mid+1 .. high]的最大子数组
	right-sum = 负无穷大
	sum = 0
	for j = mid + 1 to high
		sum = sum + A[j]
		if sum > right-sum
			right-sum = sum
			max-right = j
	return (max-left, max-right, left-sum + right-sum)
```



求解最大子数组分治算法的伪代码：

```
FIND-MAXIMUM-SUBARRAY(A, low, high) 
	// 测试子数组只有一个元素的情况
	if high == low
		return (low, high, A[low])
	else
		// 划分子数组，计算中点下标mid
		mid = 向下取整((low + high) / 2)
		
		// 递归求解左右子数组中的最大子数组
		(left-low, left-high, left-sum) =
			FIND-MAXIMUM-SUBARRAY(A, low, mid)
		(right-low, right-high, right-sum) = 
			FIND-MAXIMUM-SUBARRAY(A, mid + 1, high)
		
		// 合并工作
		(cross-low, cross-high, cross-sum) = 
			FIND-MAX-CROSSING-SUBARRAY(A, low, mid, high)
		// 检测最大和子数组是否在左子数组
		if left-sum >= right-sum and left-sum >= cross-sum
			return (left-low, left-high, left-sum)
		// 检测最大和子数组是否在右子数组
		elseif right-sum >= left-sum and right-sum >= cross-sum
			return (right-low, right-high, right-sum)
		// 最大子数组跨越中点
		else
			return (cross-low, cross-high, cross-sum)		

```

时间复杂度：

$T(n) = \Theta(1) + 2T(n/2) +  \Theta(n) + \Theta(1) = 2T(n/2) + \Theta(n)$

$\Theta(1)$: 

	if high == low
		return (low, high, A[low])
$2T(n/2)$：

	// 递归求解左右子数组中的最大子数组
	(left-low, left-high, left-sum) =
		FIND-MAXIMUM-SUBARRAY(A, low, mid)
	(right-low, right-high, right-sum) = 
		FIND-MAXIMUM-SUBARRAY(A, mid + 1, high)
$\Theta(n)$:

```
(cross-low, cross-high, cross-sum) = 
	FIND-MAX-CROSSING-SUBARRAY(A, low, mid, high)
```

$\Theta(1)$: 

```
if left-sum >= right-sum and left-sum >= cross-sum
	return (left-low, left-high, left-sum)
// 检测最大和子数组是否在右子数组
elseif right-sum >= left-sum and right-sum >= cross-sum
	return (right-low, right-high, right-sum)
// 最大子数组跨越中点
else
	return (cross-low, cross-high, cross-sum)
```

$$
T(n) = 
\begin{cases}
\Theta(1)\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ 若 n = 1\\
2T(n/2) +\Theta(n) \ 若 n > 1
\end{cases}
$$

$T(n) = \Theta(nlgn)$



## 矩阵乘法的Strassen算法

若 A = (a~ij~) 和 B = (b~ij~) 是 n × n 的方阵，则 $C = A \cdot B $ 的元素 c~ij~

$c_{ij} = \sum\limits_{k=1}^na_{ik} \cdot b_{kj}$

```lua
SQUARE-MATRIX-MULTIPLY(A, B)
	n = A, rows
	let C be a new n × n matrix
	for i = 1 to n
		for j = 1 to n
			c[i][j] = 0
		for k = 1 to n
				c[i][j] = c[i][j] + dot(a[i][k], b[k][j])
	return C
```

$T(n) = \Theta(n^3)$

### 分治算法

假定将A、B和C均分解为4个$n /2 \times n / 2$的子矩阵：
$$
A =
\begin{bmatrix}
A_{11}\ A_{12}\\
A_{21}\ A_{22}
\end{bmatrix},
B =
\begin{bmatrix}
B_{11}\ B_{12}\\
B_{21}\ B_{22}
\end{bmatrix},
C =
\begin{bmatrix}
C_{11}\ C_{12}\\
C_{21}\ C_{22}
\end{bmatrix}
（4.9）
$$
则
$$
\begin{bmatrix}
C_{11}\ C_{12}\\
C_{21}\ C_{22}
\end{bmatrix}
=
\begin{bmatrix}
A_{11}\ A_{12}\\
A_{21}\ A_{22}
\end{bmatrix}
\cdot
\begin{bmatrix}
B_{11}\ B_{12}\\
B_{21}\ B_{22}
\end{bmatrix}
$$

```
SQUARE-MATRIX-MULTIPLY_RECURSIVE(A, B)
	n = A.rows
	let C be a new n×n matrix
	if n == 1
		c[1][1] = dot(a[1][1], b[1][1])
	else partition A, B, and C as in equations(4.9)
		C[1][1] = SQUARE-MATRIX-MULTIPLY_RECURSIVE(A[1][1], B[1][1])
			+ SQUARE-MATRIX-MULTIPLY_RECURSIVE(A[1][2], B[2][1])
		C[1][2] = SQUARE-MATRIX-MULTIPLY_RECURSIVE(A[1][1], B[1][2])
			+ SQUARE-MATRIX-MULTIPLY_RECURSIVE(A[1][2], B[2][2])
		C[2][1] = SQUARE-MATRIX-MULTIPLY_RECURSIVE(A[2][1], B[1][1])
			+ SQUARE-MATRIX-MULTIPLY_RECURSIVE(A[2][2], B[2][1])
		C[2][2] = SQUARE-MATRIX-MULTIPLY_RECURSIVE(A[2][1], B[1][2])
			+ SQUARE-MATRIX-MULTIPLY_RECURSIVE(A[2][2], B[2][2])
	return C
```

$T(n) = \Theta(1) + 8T(n/2) +  \Theta(n^2) = 8T(n/2) + \Theta(n^2)$

$\Theta(1)$:

```
else partition A, B, and C as in equations(4.9)
```

$8T(n/2)$

每次递归调用完成两个n /2 * n /2 矩阵的乘法，花费T(n/2)，共8次递归。

$\Theta(n^2)$矩阵加法

```
	C[1][1] = SQUARE-MATRIX-MULTIPLY_RECURSIVE(A[1][1], B[1][1])
		+ SQUARE-MATRIX-MULTIPLY_RECURSIVE(A[1][2], B[2][1])
	C[1][2] = SQUARE-MATRIX-MULTIPLY_RECURSIVE(A[1][1], B[1][2])
		+ SQUARE-MATRIX-MULTIPLY_RECURSIVE(A[1][2], B[2][2])
	C[2][1] = SQUARE-MATRIX-MULTIPLY_RECURSIVE(A[2][1], B[1][1])
		+ SQUARE-MATRIX-MULTIPLY_RECURSIVE(A[2][2], B[2][1])
	C[2][2] = SQUARE-MATRIX-MULTIPLY_RECURSIVE(A[2][1], B[1][2])
		+ SQUARE-MATRIX-MULTIPLY_RECURSIVE(A[2][2], B[2][2])
```

### Strassen方法

略



## 用代入法求解递归式

代入法求解递归式分两步：

> 1.猜测解的形式
>
> 2.用数学归纳法求出解中的常数，并证明解是正确的。



## 用递归树方法求解递归式

## 用主方法求解递归式



# 概率分析和随机算法

## 雇佣问题

假如你要雇用一名新的办公助理。你先前的雇用尝试都失败了，于是你决定找一个雇用代
理。

雇用代理每天给你推荐一个应聘者。你面试这个人，然后决定是否雇用他。你**必须付给雇用**
**代理一小笔费用，以便面试应聘者**。然而要**真的雇用一个应聘者需要花更多的钱**，因为你必须辞掉目前的办公助理，还要付一大笔中介费给雇用代理。

你承诺在任何时候，都要找**最适合**的人来担任这项职务。因此，你决定在面试完每个应聘者后，如果该应聘者比目前的办公助理更合适，就会辞掉当前的办公助理，然后聘用新的。

你愿意为该策略付费，但希望能够估算该费用会是多少。

```
HIRE-ASSISTANT(n)
	best = 0		// candidate 0 is a least-qualified dummy candidate
	for i = 1 to n
		interview candidate i		// 面试应聘者
		if candidate i is better than candidate best
			best = i
			hire candidate i
```

以上算法总费用，$c_i$为面试费用，**较低**；$c_h$为雇佣费用，**较高**；m为雇佣人数：

总费用：$O(c_in + c_hm)$

## 指示器随机变量

给定一个样本空间S和一个事件A，那么事件A对应的指示器随机变量I(A)定义为：
$$
I(A) = 
\begin{cases}
1\ 如果A发生\\
0\ 如果A不发生
\end{cases}
$$

## 随机算法						

```
RANDOMIZED-HIRE-ASSISTANT(n)
	randomly permute the list of candidates
	best = 0		// candidate 0 is a least-qualified dummy candidate
	for i = 1 to n
		interview candidate i		// 面试应聘者
		if candidate i is better than candidate best
			best = i
			hire candidate i
```

## 概率分析和指示器随机变量的进一步使用

### 生日悖论

一个屋子里人数必须要达到多少人，才能使其中两个人的生日相同的机会达到50%

### 球与箱子

把相同的球随机投入b个箱子里，箱子的编号为1,2...b。每次投球都是独立的，均可能的落入每一个箱子里。成功是指落入指定的箱子里。

### 特征序列

抛投一枚标准的硬币n次，最长连续正面的序列的期望长度有多长？

### 在线雇佣问题

愿意雇佣接近最好的应聘者，只雇佣一次。每次面试后，必须马上提供职位给应聘者，或者马上拒绝应聘者。如何最小化面试次数和最大化雇佣应聘者质量。

解题思路：

在面试一个应聘者之后，给每人一个分数；令score(i)标识给i个应聘者分数，并且假设没有两个应聘者分数相同。在看过j个应聘者之后，我们知道这j人中哪一个分数最高，但是不知道在剩余的n-j个应聘者中会不会有更高分数的应聘者。我们决定采用这样一个策略: 

> 选择一个正整数k<n,面试然后拒绝前k个应聘者，再雇用其后比前面的应聘者有更高分数的第一个应聘者。
>
> 如果最好的应聘者在前k个面试之中，那么将雇用第n个应聘者。

```
ON-LINE-MAXIMUM(k, n)
	bestscore = 负无穷大
	for i = 1 to k
		if score(i) > bestscore
			bestscore = score(i)
	for i = k + 1 to n
		if (score(i)) > bestscore
			return i
	return n
```



# 排序和顺序统计量

排序问题：

> **输入**：一个n个数的序列$<a_1, a_2, ..., a_n>$
>
> **输出**：输入序列的一个排列（重排）$<a_1^`, a_2^`, ...,a_n^` >$，使得$a_1^`<=a_2^`<=...<=a_n^,  $



原址：

> 如果输入数组中仅有常数个元素需要在排序过程中存储在数组之外，则称排序算法是原址的。



排序的分类和运行时间

|   算法   |  最坏情况运行时间  | 平均情况/期望运行时间  |
| :------: | :----------------: | :--------------------: |
| 插入排序 |   $\Theta(n^2 )$   |     $\Theta(n^2)$      |
| 归并排序 |   $\Theta(nlgn)$   |     $\Theta(nlgn)$     |
|  堆排序  |     $O(nlgn)$      |          ---           |
| 快速排序 |   $\Theta(n^2 )$   | $\Theta(nlgn)$ (期望)  |
| 计数排序 |  $\Theta(k + n)$   |    $\Theta(k + n)$     |
| 基数排序 | $\Theta(d(k + n))$ |   $\Theta(d(k + n))$   |
|  桶排序  |   $\Theta(n^2 )$   | $\Theta(n)$ (平均情况) |



# 堆排序

## 堆

**二叉堆：**

> 是一个数组，可以看成近似的完全二叉树。树上的每个结点对应数组中的一个元素。除最底层外，该树是完全充满的，而且是从左向右填充。
>
> 表示堆的数组有两个属性：*A.length* 给出数组元素的个数，*A.heap-size*表示有多少个堆元素存储在该数组中。
>
> 0 <= *A.heap-size*  <= *A.length*

计算结点：

```Lua
PARENT(i)
	return 向下取整(i / 2)

LEFT(i)
	return 2i

RIGHT(i)
	return 2i + 1
```

![二叉堆](.\Image\二叉堆.png)



最大堆：

> 除了根以外的所有结点i都满足：`A[PARENT(i)] >= A[i]`

最小堆：

> 除了根之外的所有结点i都满足：`A[PARENT(i)] <= A[i]`

堆排序使用最大堆，最小堆常用于构建优先队列。



堆的高度：

> 一个堆中的结点的高度就是该结点到叶结点最长简单路径上的数目；把堆的高度定义为根节点的高度。
>



## 维护堆的性质

调用MAX-HEAPIFY时，假定根结点为LEFT(i)和RIGHT(i)的二叉树都是最大堆，但此时A[i]有可能小于其孩子，违背了最大堆的性质。

MAX-HEAPIFY通过让A[i]的值在最大堆中“逐级下降”，从而使得以下标i为根节点的子树重新遵循最大堆的性质。

```lua
MAX-HEAPIFY(A, i)
	l = LEFT(i)
	r = RIGHT(i)
	
	-- 从A[i]、A[LEFT(i)]、A[RIGHT(i)]中选出最大的
	if l <= A.heap-size and A[l] > A[i]
    	largest = l
    else largest = i
    if r <= A.heap-size and A[r] > A[largest]
        largest = r
    
    --[[
        最大元素是i的某个孩子结点，交换A[i]和A[largest]的值。使i和孩子都满足最大堆的性质。
        交换后，子树有可能违反最大堆性质，需要对该子树递归调用MAX-HEAPIFY
    --]]
    if largest != i
        exchange A[i] with A[largest]
        MAX-HEAPIFY(A, largest)

```

![MAX_HEAPIFY](.\Image\MAX_HEAPIFY.png)



MAX-HEAPIFY的时间复杂度是：$T(n)=O(lgn )$



## 建堆

BUILD-MAX-HEAP(A)

​	A.heap-size = A.length

​	for i = 向下取整

