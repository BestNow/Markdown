# 设计模式概述

创建型模式、结构型模式和行为型模式是软件设计模式的三个主要分类，用于解决不同类型的设计问题。

1. **创建型模式（Creational Patterns）**：
   - 创建型模式关注如何更灵活地创建对象，以便提高系统的灵活性和可扩展性。
   - 这些模式包括单例模式、工厂模式、抽象工厂模式、建造者模式和原型模式。
   - 创建型模式通常用于隐藏对象的创建逻辑，使客户端代码与具体类的创建过程解耦。

2. **结构型模式（Structural Patterns）**：
   - 结构型模式关注如何将类或对象组合成更大的结构，以解决系统中不同对象之间的关系和依赖问题。
   - 这些模式包括适配器模式、桥接模式、组合模式、装饰器模式、外观模式、享元模式和代理模式。
   - 结构型模式通常用于定义对象之间的组合关系，以便在系统中更灵活地管理对象之间的交互。

3. **行为型模式（Behavioral Patterns）**：
   - 行为型模式关注对象之间的通信和职责分配，以便更好地管理和组织系统中的行为。
   - 这些模式包括责任链模式、命令模式、解释器模式、迭代器模式、中介者模式、备忘录模式、观察者模式、状态模式、策略模式、模板方法模式和访问者模式。
   - 行为型模式通常用于定义对象之间的通信方式，以及对象如何分担职责和协作完成任务。

总的来说，创建型模式用于创建对象，结构型模式用于组织对象，行为型模式用于管理对象之间的行为和交互。这些模式可以帮助开发者更好地设计和组织软件系统，以便满足不同的需求和需求变化。



# 设计模式原则

## 依赖倒置原则(DIP)

依赖倒置原则（Dependency Inversion Principle，DIP）是面向对象设计中的一个重要原则，它提出了一种降低软件模块间耦合度的方法。DIP 的核心思想是：**高层模块不应该依赖于低层模块，二者都应该依赖于抽象**。抽象不应该依赖于具体实现细节，具体实现细节应该依赖于抽象。这一原则强调了抽象性和灵活性，使得软件系统更容易扩展、维护和测试。

以下是依赖倒置原则的一些要点：

1. **高层模块与低层模块的关系**：传统的模块设计通常是高层模块依赖于底层模块。例如，业务逻辑层依赖于数据访问层。而 DIP 告诉我们，这种关系应该反转。

2. **抽象**：DIP 强调使用抽象来解耦组件之间的关系。通过引入抽象，高层模块和低层模块可以通过共同的接口进行交互，而不需要直接依赖于彼此的具体实现。

3. **依赖注入**：依赖注入是实现 DIP 的一种常见方式。它通过将依赖对象的创建和传递移到外部环境中，使得高层模块不直接依赖于低层模块的具体实现。依赖注入可以通过构造函数、方法参数、工厂模式等方式实现。

4. **解耦性**：DIP 的目标是降低软件模块之间的耦合度，使得系统更加灵活、可维护和可扩展。通过依赖倒置，软件模块之间的依赖关系更加松散，模块的修改不会轻易影响到其他模块。

5. **设计原则的综合运用**：DIP 往往与其他设计原则一起使用，例如接口隔离原则（ISP）、单一职责原则（SRP）等。这些原则共同指导着高质量的面向对象设计。

总的来说，依赖倒置原则是面向对象设计中的一个重要原则，它通过将高层模块和低层模块之间的依赖关系进行反转，提高了系统的灵活性、可扩展性和可维护性，是实现松耦合设计的关键之一。

## 开放封闭原则(OCP)

开放封闭原则（Open-Closed Principle，OCP）是面向对象设计中的一项重要原则，由Bertrand Meyer在他的著作《面向对象软件构造》中首次提出。OCP 的核心思想是：软件实体（类、模块、函数等）应该对扩展开放，对修改关闭。换句话说，当需要改变系统行为时，应该尽量通过扩展而不是修改现有代码来实现。

以下是开放封闭原则的一些要点：

1. **对扩展开放**：软件实体应该允许在不修改其原始代码的情况下进行扩展。这意味着可以通过添加新的功能、新的模块或新的类来扩展系统的行为，而不必修改现有的代码。

2. **对修改关闭**：尽量避免修改已经存在的代码。通过遵循OCP，可以减少对现有代码的修改，从而降低了引入新错误的风险，保持了系统的稳定性。

3. **抽象和接口**：实现OCP的关键是使用抽象和接口。通过定义适当的抽象层，可以将系统中可能变化的部分隔离出来，使得扩展变得更加容易。

4. **多态性**：多态是实现OCP的重要手段之一。通过多态，可以在不修改现有代码的情况下引入新的行为。例如，通过实现新的子类并覆盖父类的方法，可以改变对象的行为。

5. **设计模式的运用**：许多设计模式，如策略模式、装饰者模式等，都是为了实现OCP而设计的。它们提供了一种结构化的方法来允许系统的行为在不修改现有代码的情况下进行扩展。

6. **测试和维护的便利性**：遵循OCP可以提高代码的可测试性和可维护性。由于系统的行为改变主要通过扩展而不是修改实现，因此新的行为可以更容易地被测试和维护。

总的来说，开放封闭原则是面向对象设计中的一个重要原则，它鼓励设计者编写具有良好扩展性和可维护性的软件系统。通过遵循OCP，可以减少对现有代码的修改，从而降低了引入新错误的风险，同时提高了系统的灵活性和稳定性。

## 单一职责原则(SRP)

单一职责原则（Single Responsibility Principle，SRP）是面向对象设计中的一个重要原则，由Robert C. Martin在他的著作《敏捷软件开发：原则、模式与实践》中首次提出。SRP 的核心思想是：一个类应该只有一个引起变化的原因，即一个类应该只负责一项功能或职责。

以下是单一职责原则的一些要点：

1. **职责的定义**：在SRP中，职责通常指类或模块承担的任务或功能。一个类的职责可能涉及到数据管理、业务逻辑、用户界面等方面。

2. **高内聚性**：SRP鼓励实现高内聚的类或模块。高内聚意味着类的各个部分都围绕着一个共同的目标或功能展开，功能相关的代码被组织在一起，从而提高了类的清晰度和可维护性。

3. **低耦合性**：SRP也有助于降低系统中各个模块之间的耦合度。当一个类只负责一个功能时，它与其他类的依赖关系更加清晰明确，从而减少了修改一个类对其他类造成的影响。

4. **单一责任的界定**：SRP并不意味着一个类只能有一个方法或只能有一个属性。而是要求一个类的所有方法和属性都围绕着一个共同的责任展开，这个责任可以通过类的名称和文档来描述。

5. **设计模式的运用**：许多设计模式，如工厂模式、策略模式等，都是为了帮助实现SRP而设计的。它们提供了一种结构化的方法来将不同的职责分离到不同的类中。

6. **可测试性和可维护性**：遵循SRP可以提高代码的可测试性和可维护性。当一个类只负责一个功能时，可以更容易地理解和测试该类的行为，从而提高了代码的质量和稳定性。

总的来说，单一职责原则是面向对象设计中的一个重要原则，它有助于提高代码的内聚性、降低耦合度，从而使得系统更加灵活、可维护和可扩展。通过将不同的职责分离到不同的类中，可以使得代码更加清晰和易于理解。

## Liskov 替换原则(LSP)

Liskov替换原则（Liskov Substitution Principle，LSP）是面向对象设计中的一个重要原则，由Barbara Liskov在1987年的一篇论文中首次提出。LSP的核心思想是：子类型必须能够替换掉其父类型而不影响程序的正确性。换句话说，派生类必须能够替代基类并出现在基类能够出现的任何地方，而不引起意外行为。

以下是Liskov替换原则的一些要点：

1. **行为一致性**：派生类应该保持与基类相同的行为。这意味着派生类不应该修改基类已经定义的行为，而应该通过扩展或重写的方式添加新的行为。

2. **接口规范**：派生类应该遵循基类所定义的接口规范。即，派生类应该实现基类所声明的所有方法，并且保持这些方法的语义一致性。

3. **子类型的自由性**：LSP鼓励对子类型进行自由的扩展和修改，但是需要保证不破坏与基类的兼容性。这样可以提高系统的灵活性和可扩展性。

4. **设计约束**：LSP对继承层次结构的设计提出了一些约束，例如，避免在派生类中修改基类的行为，避免向基类添加新的预条件等。

5. **应用场景**：LSP适用于所有使用继承的场景，包括子类化、实现接口等。它有助于确保在使用多态性时程序的行为是可预测的和正确的。

6. **测试和维护的便利性**：遵循LSP可以提高代码的可测试性和可维护性。由于子类型可以替代其父类型，在测试和维护时可以更加灵活地使用派生类来代替基类。

总的来说，Liskov替换原则是面向对象设计中的一个重要原则，它有助于确保继承关系的正确性和稳定性。通过遵循LSP，可以更好地利用多态性和继承特性，使得系统更加灵活和可扩展。

## 接口隔离原则(ISP)

接口隔离原则（Interface Segregation Principle，ISP）是面向对象设计中的一个重要原则，由Robert C. Martin在他的著作《敏捷软件开发：原则、模式与实践》中提出。ISP的核心思想是：一个类对另一个类的依赖应该建立在最小的接口上。换句话说，不应该强迫客户端依赖于它们不需要的接口。

以下是接口隔离原则的一些要点：

1. **接口的粒度**：ISP强调设计接口时应该考虑接口的粒度，接口应该尽可能小，并且应该根据客户端的需求来定义。这样可以避免客户端依赖于它们不需要的方法，从而降低了类之间的耦合度。

2. **接口的一致性**：接口应该具有一致性，即相同功能的方法应该归于同一个接口。这样可以使得接口更加清晰和易于理解。

3. **分离不同的职责**：ISP鼓励将不同的职责分离到不同的接口中。例如，一个包含多个功能的接口可以被拆分成多个小的接口，每个接口只包含相关的一组功能。

4. **接口的透明性**：接口应该尽量透明，即客户端不需要了解接口的内部实现细节。这样可以降低接口的复杂度，提高系统的可维护性和可扩展性。

5. **避免"胖接口"**："胖接口"指的是包含了太多方法的接口，这样的接口会导致客户端依赖于它们不需要的方法。因此，应该避免设计"胖接口"，而是尽量设计精简的、专注的接口。

6. **设计模式的运用**：许多设计模式，如适配器模式、桥接模式等，都是为了帮助实现ISP而设计的。它们提供了一种结构化的方法来分离接口，使得系统更加灵活和可维护。

总的来说，接口隔离原则是面向对象设计中的一个重要原则，它有助于降低类之间的耦合度，提高系统的灵活性和可维护性。通过设计精简、专注的接口，可以使得系统更加清晰和易于理解，并且更容易适应变化。

## 对象组合优于类继承

## 封装变化点

## 面向接口编程



# 设计模式分类

设计模式一共有 23 种，按照模式分类并给出每个设计模式的定义如下：

## 创建型模式（Creational Patterns）

1. **单例模式（Singleton Pattern）**：确保一个类只有一个实例，并提供一个全局访问点。
   
2. **工厂方法模式（Factory Method Pattern）**：定义一个用于创建对象的接口，但让子类决定实例化哪个类。
   
3. **抽象工厂模式（Abstract Factory Pattern）**：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。
   
4. **建造者模式（Builder Pattern）**：将一个复杂对象的构建与其表示分离，使同样的构建过程可以创建不同的表示。
   
5. **原型模式（Prototype Pattern）**：通过复制现有对象来创建新对象，而不是通过实例化。

## 结构型模式（Structural Patterns）

6. **适配器模式（Adapter Pattern）**：将一个类的接口转换成客户希望的另一个接口。
7. **桥接模式（Bridge Pattern）**：将抽象部分与其实现部分分离，使它们可以独立地变化。
8. **组合模式（Composite Pattern）**：将对象组合成树形结构以表示"部分-整体"的层次结构。
9. **代理模式（Proxy Pattern）**：允许你提供一个代理对象，以控制对其它对象的访问。
10. **装饰器模式（Decorator Pattern）**：动态地给一个对象添加一些额外的职责。
11. **外观模式（Facade Pattern）**：提供一个统一的接口，用来访问子系统中的一群接口。
11. **享元模式（Flyweight Pattern）**：使用共享对象来支持大量细粒度的对象。

## 行为型模式（Behavioral Patterns）

12. **责任链模式（Chain of Responsibility Pattern）**：使多个对象都有机会处理请求，从而避免请求的发送者与接收者之间的耦合。
    
13. **命令模式（Command Pattern）**：将请求封装成一个对象，从而使您可以参数化客户端对象。
    
14. **解释器模式（Interpreter Pattern）**：给定一个语言，定义它的文法的一种表示，并定义一个解释器。
    
15. **迭代器模式（Iterator Pattern）**：提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示。
    
16. **中介者模式（Mediator Pattern）**：用一个中介对象来封装一系列的对象交互。
    
17. **备忘录模式（Memento Pattern）**：在不违反封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。
    
18. **观察者模式（Observer Pattern）**：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动更新。
    
19. **状态模式（State Pattern）**：允许对象在内部状态改变时改变它的行为。
    
20. **策略模式（Strategy Pattern）**：定义一系列算法，将每个算法封装起来，并使它们可以互换。
    
21. **模板方法模式（Template Method Pattern）**：定义一个操作中的算法的框架，而将一些步骤延迟到子类中。
    
22. **访问者模式（Visitor Pattern）**：表示一个作用于某对象结构中的各元素的操作。它使您可以在不改变各元素类的前提下定义作用于这些元素的新操作。



# 创建型模式（Creational Patterns）

## 单例模式（Singleton Pattern）

### 应用场景

单例模式适用于以下情况：
1. 当系统中的某个类只需要拥有一个实例，并且客户端需要全局访问该实例时，可以使用单例模式。
2. 当需要控制某个资源的访问权限，例如数据库连接池、线程池等，可以使用单例模式来确保只有一个实例被访问。

### 详细说明
单例模式确保一个类只有一个实例，并提供一个全局访问点来访问该实例。通常，单例模式的实现包括：
1. 私有化构造函数，防止外部直接实例化对象。
2. 提供一个静态方法来获取单例对象的实例。
3. 使用静态成员变量来保存单例对象的实例。

### C++ 代码示例

#### 单线程版本

下面是一个简单的单例模式的 C++ 代码示例：

```cpp
#include <iostream>

class Singleton {
private:
    // 私有的静态成员变量，用于保存单例对象的实例
    static Singleton* instance;

    // 私有的构造函数，防止外部直接实例化对象
    Singleton() {
        std::cout << "Singleton instance created." << std::endl;
    }

public:
    // 静态方法，用于获取单例对象的实例
    static Singleton* getInstance() {
        // 如果实例不存在，则创建新实例
        if (instance == nullptr) {
            instance = new Singleton();
        }
        return instance;
    }

    // 其他成员方法
    void someMethod() {
        std::cout << "Some method of Singleton" << std::endl;
    }
};

// 初始化静态成员变量
Singleton* Singleton::instance = nullptr;

int main() {
    // 获取单例对象的实例
    Singleton* singleton1 = Singleton::getInstance();
    Singleton* singleton2 = Singleton::getInstance();

    // 验证是否为同一个实例
    std::cout << "Is singleton1 the same as singleton2? " << (singleton1 == singleton2 ? "Yes" : "No") << std::endl;

    // 调用单例对象的方法
    singleton1->someMethod();

    return 0;
}
```

在这个示例中，`Singleton` 类表示单例对象。`getInstance()` 方法用于获取单例对象的实例，并确保只有一个实例被创建。通过调用 `getInstance()` 方法可以获得单例对象的实例。



#### 多线程版本

```cpp
#include <iostream>
#include <mutex>
#include <atomic>

class Singleton {
private:
    static std::atomic<Singleton*> instance;
    static std::mutex mutex_; // 用于保证多线程安全的互斥锁

    Singleton() {
        std::cout << "Singleton instance created." << std::endl;
    }

public:
    // 获取单例对象的实例
    static Singleton* getInstance() {
        // 使用双重检查锁定（Double-Checked Locking）来确保线程安全且减少锁的竞争
        if (instance.load(std::memory_order_acquire) == nullptr) {
            std::lock_guard<std::mutex> lock(mutex_); // 加锁
            if (instance.load(std::memory_order_relaxed) == nullptr) {
                Singleton* temp = new Singleton();
                instance.store(temp, std::memory_order_release); // 指针赋值使用适当的内存顺序
            }
        }
        return instance.load(std::memory_order_acquire);
    }

    // 其他成员方法
    void someMethod() {
        std::cout << "Some method of Singleton" << std::endl;
    }
};

std::atomic<Singleton*> Singleton::instance(nullptr);
std::mutex Singleton::mutex_;

int main() {
    // 创建多个线程来获取单例对象的实例
    std::thread threads[5];
    for (int i = 0; i < 5; ++i) {
        threads[i] = std::thread([](){
            Singleton* singleton = Singleton::getInstance();
            // 调用单例对象的方法
            singleton->someMethod();
        });
    }

    // 等待所有线程结束
    for (int i = 0; i < 5; ++i) {
        threads[i].join();
    }

    return 0;
}
```

在这个改进后的示例中，使用 `std::atomic` 来声明 `instance`，并在 `getInstance()` 方法中使用适当的内存顺序。这样可以确保在多线程环境下正确地读取和写入 `instance` 指针。



## 工厂方法模式（Factory Method Pattern）

### 应用场景
工厂方法模式适用于以下情况：
1. 当一个类不知道它所需要的对象的类时，可以使用工厂方法模式。客户端只需知道具体工厂的名称，无需知道具体产品的名称，就可以创建对象。
2. 当一个类希望由它的子类来指定所创建对象的具体类时，可以使用工厂方法模式。通过子类化来决定实例化哪个类。

### 详细说明
工厂方法模式定义了一个用于创建对象的接口，但由子类决定要实例化的类。这样，工厂方法模式允许类将实例化延迟到子类。工厂方法模式使一个类的实例化延迟到了子类，从而满足了单一职责原则，即一个类应该只有一个引起变化的原因。

### C++ 代码示例
下面是一个简单的工厂方法模式的 C++ 代码示例：

```cpp
#include <iostream>
#include <string>

// 抽象产品类
class Product {
public:
    virtual void operation() = 0;
};

// 具体产品类A
class ConcreteProductA : public Product {
public:
    void operation() override {
        std::cout << "Concrete Product A operation." << std::endl;
    }
};

// 具体产品类B
class ConcreteProductB : public Product {
public:
    void operation() override {
        std::cout << "Concrete Product B operation." << std::endl;
    }
};

// 抽象工厂类
class Factory {
public:
    virtual Product* createProduct() = 0;
};

// 具体工厂类A，用于创建具体产品类A的实例
class ConcreteFactoryA : public Factory {
public:
    Product* createProduct() override {
        return new ConcreteProductA();
    }
};

// 具体工厂类B，用于创建具体产品类B的实例
class ConcreteFactoryB : public Factory {
public:
    Product* createProduct() override {
        return new ConcreteProductB();
    }
};

int main() {
    // 创建具体工厂A的实例
    Factory* factoryA = new ConcreteFactoryA();
    // 使用工厂A创建产品A
    Product* productA = factoryA->createProduct();
    // 调用产品A的操作
    productA->operation();
    // 释放产品A的内存
    delete productA;
    // 释放工厂A的内存
    delete factoryA;

    // 创建具体工厂B的实例
    Factory* factoryB = new ConcreteFactoryB();
    // 使用工厂B创建产品B
    Product* productB = factoryB->createProduct();
    // 调用产品B的操作
    productB->operation();
    // 释放产品B的内存
    delete productB;
    // 释放工厂B的内存
    delete factoryB;

    return 0;
}
```

在这个示例中，抽象产品类 `Product` 定义了产品的通用接口。具体产品类 `ConcreteProductA` 和 `ConcreteProductB` 实现了具体产品的功能。抽象工厂类 `Factory` 定义了工厂方法 `createProduct()`，用于创建产品对象。具体工厂类 `ConcreteFactoryA` 和 `ConcreteFactoryB` 实现了工厂方法，分别用于创建具体产品类A和具体产品类B的实例。在 `main()` 函数中，使用具体工厂类创建产品，并调用产品的操作。



## 抽象工厂模式（Abstract Factory Pattern）

### 应用场景
抽象工厂模式适用于以下情况：
1. 当一个系统需要独立于其产品的创建、组合和表示时，可以使用抽象工厂模式。这使得系统更容易扩展，因为它提供了一种分离具体类创建和使用的方法。
2. 当一个系统需要一组**相关或依赖**的对象族，而不需要关心它们的具体类时，可以使用抽象工厂模式。这种情况下，抽象工厂模式可以帮助客户端创建一系列相关或依赖的对象，而不需要知道每个对象的具体类。

### 详细说明
抽象工厂模式提供了一种接口，用于创建一系列相关或依赖的对象，而无需指定其具体类。它通过提供一组工厂方法，每个工厂方法用于创建一种类型的对象，来达到这个目的。客户端只需要通过抽象工厂接口来创建对象，而无需关心对象的具体类。这样可以实现对象的解耦和系统的灵活性。

### C++ 代码示例
下面是一个简单的抽象工厂模式的 C++ 代码示例：

```cpp
#include <iostream>

// 抽象产品A
class AbstractProductA {
public:
    virtual void operationA() = 0;
};

// 具体产品A1
class ConcreteProductA1 : public AbstractProductA {
public:
    void operationA() override {
        std::cout << "Concrete Product A1 operation." << std::endl;
    }
};

// 具体产品A2
class ConcreteProductA2 : public AbstractProductA {
public:
    void operationA() override {
        std::cout << "Concrete Product A2 operation." << std::endl;
    }
};

// 抽象产品B
class AbstractProductB {
public:
    virtual void operationB() = 0;
};

// 具体产品B1
class ConcreteProductB1 : public AbstractProductB {
public:
    void operationB() override {
        std::cout << "Concrete Product B1 operation." << std::endl;
    }
};

// 具体产品B2
class ConcreteProductB2 : public AbstractProductB {
public:
    void operationB() override {
        std::cout << "Concrete Product B2 operation." << std::endl;
    }
};

// 抽象工厂
class AbstractFactory {
public:
    virtual AbstractProductA* createProductA() = 0;
    virtual AbstractProductB* createProductB() = 0;
};

// 具体工厂1
class ConcreteFactory1 : public AbstractFactory {
public:
    AbstractProductA* createProductA() override {
        return new ConcreteProductA1();
    }
    
    AbstractProductB* createProductB() override {
        return new ConcreteProductB1();
    }
};

// 具体工厂2
class ConcreteFactory2 : public AbstractFactory {
public:
    AbstractProductA* createProductA() override {
        return new ConcreteProductA2();
    }
    
    AbstractProductB* createProductB() override {
        return new ConcreteProductB2();
    }
};

int main() {
    // 创建具体工厂1的实例
    AbstractFactory* factory1 = new ConcreteFactory1();
    // 使用工厂1创建产品A
    AbstractProductA* productA1 = factory1->createProductA();
    // 使用工厂1创建产品B
    AbstractProductB* productB1 = factory1->createProductB();
    // 调用产品A和产品B的操作
    productA1->operationA();
    productB1->operationB();

    // 释放产品A和产品B的内存
    delete productA1;
    delete productB1;
    // 释放工厂1的内存
    delete factory1;

    // 创建具体工厂2的实例
    AbstractFactory* factory2 = new ConcreteFactory2();
    // 使用工厂2创建产品A
    AbstractProductA* productA2 = factory2->createProductA();
    // 使用工厂2创建产品B
    AbstractProductB* productB2 = factory2->createProductB();
    // 调用产品A和产品B的操作
    productA2->operationA();
    productB2->operationB();

    // 释放产品A和产品B的内存
    delete productA2;
    delete productB2;
    // 释放工厂2的内存
    delete factory2;

    return 0;
}
```

在这个示例中，抽象工厂模式包括抽象产品类 `AbstractProductA` 和 `AbstractProductB`，以及抽象工厂类 `AbstractFactory`。具体的产品类 `ConcreteProductA1`、`ConcreteProductA2`、`ConcreteProductB1` 和 `ConcreteProductB2` 实现了抽象产品的接口。具体的工厂类 `ConcreteFactory1` 和 `ConcreteFactory2` 分别实现了抽象工厂的接口，用于创建具体的产品对象。客户端根据不同的具体工厂来创建产品对象，从而实现了对象的解耦。



## 建造者模式（Builder Pattern）

### 应用场景
建造者模式适用于以下情况：
1. 当一个复杂对象的创建过程需要独立于其组成部分以及它们的装配方式时，可以使用建造者模式。这样可以使得同样的创建过程可以创建不同的表示形式。
2. 当需要创建一个对象的部分表示形式，并且需要根据一定的步骤来构建这个对象时，可以使用建造者模式。这种情况下，建造者模式可以帮助客户端逐步构建对象，而不必一次性指定所有参数。

### 详细说明
建造者模式通过将复杂对象的创建过程分解为多个步骤，并提供一个统一的接口来构建对象，使得客户端可以根据需要自由组合不同的步骤和参数来构建对象。具体来说，建造者模式包括以下几个角色：
- Director（指挥者）：负责指导构建过程的顺序，调用建造者来构建产品。
- Builder（建造者）：定义构建产品的接口，包括各个部分的构建方法。
- ConcreteBuilder（具体建造者）：实现建造者接口，负责构建产品的各个部分。
- Product（产品）：最终构建出的复杂对象。

建造者模式的优点包括：
- 将复杂对象的创建过程封装在建造者中，使得客户端可以根据需要自由组合步骤和参数来构建对象，提高了灵活性和可定制性。
- 将产品的构建过程与其表示形式分离，使得可以更容易地扩展或修改产品的内部表示。

### C++ 代码示例
以下是一个简单的建造者模式的 C++ 代码示例：

```cpp
#include <iostream>
#include <string>
#include <vector>

// 产品类
class Product {
public:
    void addPart(const std::string& part) {
        parts.push_back(part);
    }

    void show() const {
        std::cout << "Product Parts: ";
        for (const auto& part : parts) {
            std::cout << part << ", ";
        }
        std::cout << std::endl;
    }

private:
    std::vector<std::string> parts;
};

// 建造者接口
class Builder {
public:
    virtual void buildPartA() = 0;
    virtual void buildPartB() = 0;
    virtual Product* getProduct() = 0;
};

// 具体建造者A
class ConcreteBuilderA : public Builder {
public:
    void buildPartA() override {
        product.addPart("PartA1");
    }

    void buildPartB() override {
        product.addPart("PartB1");
    }

    Product* getProduct() override {
        return &product;
    }

private:
    Product product;
};

// 具体建造者B
class ConcreteBuilderB : public Builder {
public:
    void buildPartA() override {
        product.addPart("PartA2");
    }

    void buildPartB() override {
        product.addPart("PartB2");
    }

    Product* getProduct() override {
        return &product;
    }

private:
    Product product;
};

// 指挥者
class Director {
public:
    Director(Builder* builder) : builder(builder) {}

    void construct() {
        builder->buildPartA();
        builder->buildPartB();
    }

private:
    Builder* builder;
};

int main() {
    // 使用具体建造者A构建产品
    Builder* builderA = new ConcreteBuilderA();
    Director directorA(builderA);
    directorA.construct();
    Product* productA = builderA->getProduct();
    productA->show();
    delete builderA;

    // 使用具体建造者B构建产品
    Builder* builderB = new ConcreteBuilderB();
    Director directorB(builderB);
    directorB.construct();
    Product* productB = builderB->getProduct();
    productB->show();
    delete builderB;

    return 0;
}
```

在这个示例中，建造者模式包括抽象建造者 `Builder`、具体建造者 `ConcreteBuilderA` 和 `ConcreteBuilderB`、产品 `Product` 以及指挥者 `Director`。客户端根据需要选择具体的建造者，并由指挥者来指导构建过程，最终得到构建好的产品。

## 原型模式（Prototype Pattern）

### 应用场景
原型模式适用于以下情况：
1. 当一个系统需要创建多个相似但不完全相同的对象时，可以使用原型模式。通过克隆已有对象来创建新对象，可以避免重复的初始化操作，提高性能和效率。
2. 当一个对象的创建过程比较复杂或涉及到深层次的复制时，可以使用原型模式。通过原型模式可以简化对象的创建过程，减少对已有代码的修改。

### 详细说明
原型模式是一种创建型设计模式，它允许通过复制现有对象来创建新对象，而不是通过实例化类来创建。原型模式基于原型实例创建对象，当直接创建对象的过程很昂贵或很复杂时，可以使用原型模式来提高性能和简化代码。

在原型模式中，对象通常实现一个克隆方法，用于创建对象的副本。当需要创建新对象时，客户端可以通过调用原型对象的克隆方法来复制对象，而不是通过实例化新对象。

### C++ 代码示例
以下是一个简单的原型模式的 C++ 代码示例：

```cpp
#include <iostream>
#include <string>

// 原型类
class Prototype {
public:
    virtual Prototype* clone() const = 0; // 克隆方法
    virtual void print() const = 0; // 打印方法
};

// 具体原型类A
class ConcretePrototypeA : public Prototype {
private:
    std::string data_;

public:
    ConcretePrototypeA(const std::string& data) : data_(data) {}

    // 克隆方法的实现
    ConcretePrototypeA* clone() const override {
        return new ConcretePrototypeA(*this);
    }

    // 打印方法的实现
    void print() const override {
        std::cout << "ConcretePrototypeA: " << data_ << std::endl;
    }
};

// 具体原型类B
class ConcretePrototypeB : public Prototype {
private:
    int value_;

public:
    ConcretePrototypeB(int value) : value_(value) {}

    // 克隆方法的实现
    ConcretePrototypeB* clone() const override {
        return new ConcretePrototypeB(*this);
    }

    // 打印方法的实现
    void print() const override {
        std::cout << "ConcretePrototypeB: " << value_ << std::endl;
    }
};

int main() {
    // 创建具体原型类A的实例
    ConcretePrototypeA* prototypeA = new ConcretePrototypeA("Prototype A");
    // 克隆具体原型类A的实例
    Prototype* cloneA = prototypeA->clone();
    // 打印克隆的实例
    cloneA->print();

    // 创建具体原型类B的实例
    ConcretePrototypeB* prototypeB = new ConcretePrototypeB(100);
    // 克隆具体原型类B的实例
    Prototype* cloneB = prototypeB->clone();
    // 打印克隆的实例
    cloneB->print();

    // 释放内存
    delete prototypeA;
    delete cloneA;
    delete prototypeB;
    delete cloneB;

    return 0;
}
```

在这个示例中，`Prototype` 是抽象原型类，定义了克隆方法和打印方法。具体原型类 `ConcretePrototypeA` 和 `ConcretePrototypeB` 实现了抽象原型类的方法，分别提供了不同的数据。在客户端中，创建具体原型类的实例，并通过调用克隆方法来复制对象，最后打印克隆的实例。



# 结构型模式（Structural Patterns）

## 适配器模式（Adapter Pattern）

### 应用场景：
适配器模式适用于以下情况：
1. 当需要使用一个已存在的类，但是其接口与系统要求不兼容时，可以使用适配器模式。适配器模式可以将已有的类适配为符合系统接口的新类，从而使得原有的类可以在系统中被复用。
2. 当需要创建一个可复用的类，该类可以与多个不兼容的类交互时，可以使用适配器模式。适配器模式可以封装不兼容类的接口，使得其他类可以与这些不兼容的类交互，而不必了解其具体实现。

### 详细说明：
适配器模式是一种结构型设计模式，它允许将一个接口转换成客户端所期望的另一个接口。适配器模式主要包含三种角色：目标接口（Target）、适配器（Adapter）和适配者（Adaptee）。
- 目标接口定义了客户端所期望的接口。
- 适配器是一个类，实现了目标接口，并持有一个适配者的实例，用于将适配者的接口转换为目标接口。
- 适配者是客户端需要适配的类，它的接口与目标接口不兼容。

### C++ 代码示例：
以下是一个简单的适配器模式的 C++ 代码示例：

```cpp
#include <iostream>

// 目标接口
class Target {
public:
    virtual void request() const = 0;
};

// 适配者
class Adaptee {
public:
    void specificRequest() const {
        std::cout << "Adaptee: specific request" << std::endl;
    }
};

// 适配器
class Adapter : public Target {
private:
    Adaptee* adaptee_;

public:
    Adapter(Adaptee* adaptee) : adaptee_(adaptee) {}

    void request() const override {
        std::cout << "Adapter: request" << std::endl;
        adaptee_->specificRequest();
    }
};

int main() {
    // 创建适配者的实例
    Adaptee* adaptee = new Adaptee();
    // 创建适配器的实例，将适配者传入适配器
    Target* adapter = new Adapter(adaptee);
    // 调用目标接口的方法，实际上调用了适配者的方法
    adapter->request();

    // 释放内存
    delete adaptee;
    delete adapter;

    return 0;
}
```

在这个示例中，`Target` 是目标接口，`Adaptee` 是适配者类，具有一个 `specificRequest()` 方法。`Adapter` 是适配器类，实现了目标接口，并持有一个适配者类的实例。在客户端中，创建适配器的实例，并将适配者的实例传入适配器。调用目标接口的方法时，实际上调用了适配者的方法，从而实现了适配器模式。

## 桥接模式（Bridge Pattern）

### 应用场景
桥接模式适用于以下情况：
1. 当一个类存在两个独立变化的维度时，可以使用桥接模式。桥接模式可以将抽象部分与其实现部分分离，使它们可以独立地变化，从而提高系统的灵活性。
2. 当一个类需要在运行时选择或切换其实现时，可以使用桥接模式。桥接模式可以通过组合来选择或切换不同的实现，而不必修改类的抽象部分。

### 详细说明
桥接模式是一种结构型设计模式，它将抽象部分和实现部分分离，使它们可以独立地变化。桥接模式主要包含两种角色：抽象部分（Abstraction）和实现部分（Implementation）。
- 抽象部分定义了抽象接口，并维护一个指向实现部分的引用。
- 实现部分提供了具体的实现，但不需要了解抽象部分的接口。

### C++ 代码示例
以下是一个简单的桥接模式的 C++ 代码示例：

```cpp
#include <iostream>

// 实现部分接口
class Implementor {
public:
    virtual void operationImpl() const = 0;
};

// 具体实现A
class ConcreteImplementorA : public Implementor {
public:
    void operationImpl() const override {
        std::cout << "Concrete Implementor A operation" << std::endl;
    }
};

// 具体实现B
class ConcreteImplementorB : public Implementor {
public:
    void operationImpl() const override {
        std::cout << "Concrete Implementor B operation" << std::endl;
    }
};

// 抽象部分
class Abstraction {
protected:
    Implementor* implementor_;

public:
    Abstraction(Implementor* implementor) : implementor_(implementor) {}

    virtual void operation() const = 0;
};

// 扩展抽象部分A
class RefinedAbstractionA : public Abstraction {
public:
    RefinedAbstractionA(Implementor* implementor) : Abstraction(implementor) {}

    void operation() const override {
        std::cout << "Refined Abstraction A operation" << std::endl;
        implementor_->operationImpl();
    }
};

// 扩展抽象部分B
class RefinedAbstractionB : public Abstraction {
public:
    RefinedAbstractionB(Implementor* implementor) : Abstraction(implementor) {}

    void operation() const override {
        std::cout << "Refined Abstraction B operation" << std::endl;
        implementor_->operationImpl();
    }
};

int main() {
    // 创建具体实现A的实例
    Implementor* implementorA = new ConcreteImplementorA();
    // 创建扩展抽象部分A的实例，传入具体实现A的实例
    Abstraction* abstractionA = new RefinedAbstractionA(implementorA);
    // 调用扩展抽象部分A的方法，实际上调用了具体实现A的方法
    abstractionA->operation();

    // 创建具体实现B的实例
    Implementor* implementorB = new ConcreteImplementorB();
    // 创建扩展抽象部分B的实例，传入具体实现B的实例
    Abstraction* abstractionB = new RefinedAbstractionB(implementorB);
    // 调用扩展抽象部分B的方法，实际上调用了具体实现B的方法
    abstractionB->operation();

    // 释放内存
    delete implementorA;
    delete abstractionA;
    delete implementorB;
    delete abstractionB;

    return 0;
}
```

在这个示例中，`Implementor` 是实现部分的接口，定义了操作的具体实现。`ConcreteImplementorA` 和 `ConcreteImplementorB` 是具体实现类，分别提供了不同的实现。`Abstraction` 是抽象部分的接口，维护一个指向实现部分的引用。`RefinedAbstractionA` 和 `RefinedAbstractionB` 是扩展抽象部分的类，实现了抽象部分的接口，并调用了实现部分的方法。在客户端中，创建具体实现的实例，并将其传入扩展抽象部分的实例，最后调用扩展抽象部分的方法，实际上调用了具体实现的方法，从而实现了桥接模式。

## 组合模式（Composite Pattern）

### 应用场景
组合模式适用于以下情况：
1. 当需要表示对象的部分-整体层次结构，并且希望客户端统一对待单个对象和组合对象时，可以使用组合模式。组合模式允许客户端使用统一的方式处理单个对象和组合对象，而不必关心其内部结构。
2. 当需要对树状结构进行递归操作时，可以使用组合模式。组合模式可以通过递归方式处理树状结构的每个节点，从而简化了对树的操作。

### 详细说明
组合模式是一种结构型设计模式，它允许将对象组合成树状结构以表示部分-整体层次关系。组合模式主要包含两种角色：叶子节点（Leaf）和组合节点（Composite）。
- 叶子节点代表了树状结构中的最小单位，它不包含子节点。
- 组合节点代表了树状结构中的内部节点，它包含了一个或多个子节点。

组合模式通过统一的方式处理单个对象和组合对象，使得客户端可以使用相同的方式处理整个树状结构，而不必关心节点的具体类型。

### C++ 代码示例
以下是一个简单的组合模式的 C++ 代码示例：

```cpp
#include <iostream>
#include <vector>

// 组件接口
class Component {
public:
    virtual void operation() const = 0;
};

// 叶子节点
class Leaf : public Component {
public:
    void operation() const override {
        std::cout << "Leaf operation" << std::endl;
    }
};

// 组合节点
class Composite : public Component {
private:
    std::vector<Component*> children_;

public:
    void add(Component* component) {
        children_.push_back(component);
    }

    void operation() const override {
        std::cout << "Composite operation" << std::endl;
        for (auto child : children_) {
            child->operation();
        }
    }
};

int main() {
    // 创建叶子节点
    Leaf* leaf1 = new Leaf();
    Leaf* leaf2 = new Leaf();
    // 创建组合节点
    Composite* composite = new Composite();
    // 将叶子节点添加到组合节点中
    composite->add(leaf1);
    composite->add(leaf2);

    // 调用组合节点的操作，实际上调用了叶子节点的操作
    composite->operation();

    // 释放内存
    delete leaf1;
    delete leaf2;
    delete composite;

    return 0;
}
```

在这个示例中，`Component` 是组件的抽象接口，定义了操作的方法。`Leaf` 是叶子节点类，实现了组件接口的方法。`Composite` 是组合节点类，包含了一个 `std::vector<Component*>` 类型的成员变量，用于存储子节点。在客户端中，创建叶子节点和组合节点，将叶子节点添加到组合节点中。调用组合节点的操作方法时，实际上调用了叶子节点的操作方法，从而实现了组合模式。



## 代理模式（Proxy Pattern）

代理模式（Proxy Pattern）的应用场景非常广泛，它可以在很多情况下发挥作用。下面详细说明了代理模式的应用场景、原理和一个简单的 C++ 代码示例：

### 应用场景

1. **远程代理**：允许客户端通过代理对象来访问远程主机上的对象。这在分布式系统中是非常常见的，例如通过 Web 服务或远程方法调用（RPC）访问远程服务器。
   
2. **虚拟代理**：在需要创建昂贵对象时，可以使用虚拟代理延迟实际对象的创建。例如，当一个图像或视频需要从磁盘加载时，可以使用虚拟代理来显示一个占位符，直到实际图像或视频加载完成。

3. **保护代理**：用于控制对敏感对象的访问。代理可以验证客户端的请求是否符合访问权限，然后再将请求转发给真实对象。

4. **缓存代理**：用于缓存频繁访问的数据，以减少对真实对象的访问次数。代理可以在访问真实对象之前检查缓存，并在缓存中找到请求的数据时直接返回它，而不需要访问真实对象。

### 原理

代理模式由三个主要组件组成：

1. **抽象主题（Subject）**：声明了代理和真实对象的共同接口。
   
2. **真实主题（Real Subject）**：定义了真实对象的具体类，是被代理的对象。
   
3. **代理（Proxy）**：持有一个指向真实对象的引用，并提供与真实对象相同的接口。客户端通过代理访问真实对象。

### C++代码示例

下面是一个简单的使用代理模式的 C++ 代码示例，模拟一个远程代理的场景：

```cpp
#include <iostream>
#include <string>

// 抽象主题：定义了代理和真实对象的共同接口
class Subject {
public:
    virtual void request() const = 0;
};

// 真实主题：定义了真实对象的具体类
class RealSubject : public Subject {
public:
    void request() const override {
        std::cout << "RealSubject: Handling request." << std::endl;
    }
};

// 代理：持有一个指向真实对象的引用，并提供与真实对象相同的接口
class Proxy : public Subject {
private:
    RealSubject* realSubject;

public:
    Proxy() : realSubject(nullptr) {}

    void request() const override {
        if (!realSubject) {
            std::cout << "Proxy: Creating real subject." << std::endl;
            realSubject = new RealSubject();
        }
        std::cout << "Proxy: Forwarding request to real subject." << std::endl;
        realSubject->request();
    }

    ~Proxy() {
        delete realSubject;
    }
};

int main() {
    Proxy proxy;
    proxy.request();

    return 0;
}
```

在上面的示例中，`Subject` 是抽象主题，定义了代理和真实对象的共同接口 `request`。`RealSubject` 是真实主题，定义了真实对象的具体类。`Proxy` 是代理，持有一个指向真实对象的引用，并提供与真实对象相同的接口。在 `main` 函数中，创建了一个代理对象，并通过代理对象访问真实对象的方法。

## 装饰器模式（Decorator Pattern）

### 应用场景
装饰器模式适用于以下情况：
1. 当需要在不修改现有对象结构的情况下，动态地为对象添加新的功能时，可以使用装饰器模式。装饰器模式允许通过将对象包装在装饰器对象中来扩展其功能，而不影响原始对象的接口和行为。
2. 当需要为一个类的一部分对象添加功能，而不是整个对象时，可以使用装饰器模式。装饰器模式允许将功能分解为单独的装饰器类，并根据需要组合它们，从而灵活地添加功能。

### 详细说明
装饰器模式是一种结构型设计模式，它允许在不修改现有对象的情况下动态地为对象添加新的功能。装饰器模式主要包含三种角色：组件（Component）、具体组件（Concrete Component）和装饰器（Decorator）。
- 组件定义了对象的基本接口，所有具体组件和装饰器都实现了该接口。
- 具体组件是被装饰的对象，它实现了组件接口，并提供了基本的功能。
- 装饰器是一个抽象类，它实现了组件接口，并持有一个组件对象的引用。装饰器可以通过组合的方式来扩展组件的功能。

### C++ 代码示例
以下是一个简单的装饰器模式的 C++ 代码示例：

```cpp
#include <iostream>

// 抽象组件
class Component {
public:
    virtual void operation() const = 0;
};

// 具体组件
class ConcreteComponent : public Component {
public:
    void operation() const override {
        std::cout << "ConcreteComponent: operation" << std::endl;
    }
};

// 抽象装饰器
class Decorator : public Component {
protected:
    Component* component_;

public:
    Decorator(Component* component) : component_(component) {}

    void operation() const override {
        if (component_)
            component_->operation();
    }
};

// 具体装饰器A
class ConcreteDecoratorA : public Decorator {
public:
    ConcreteDecoratorA(Component* component) : Decorator(component) {}

    void operation() const override {
        Decorator::operation();
        addBehavior();
    }

    void addBehavior() const {
        std::cout << "ConcreteDecoratorA: additional behavior" << std::endl;
    }
};

// 具体装饰器B
class ConcreteDecoratorB : public Decorator {
public:
    ConcreteDecoratorB(Component* component) : Decorator(component) {}

    void operation() const override {
        Decorator::operation();
        addBehavior();
    }

    void addBehavior() const {
        std::cout << "ConcreteDecoratorB: additional behavior" << std::endl;
    }
};

int main() {
    // 创建具体组件
    Component* component = new ConcreteComponent();
    // 使用具体装饰器A装饰具体组件
    Component* decoratedComponentA = new ConcreteDecoratorA(component);
    // 使用具体装饰器B装饰具体组件
    Component* decoratedComponentB = new ConcreteDecoratorB(component);

    // 调用被装饰的对象的操作
    std::cout << "Decorated Component A: ";
    decoratedComponentA->operation();

    std::cout << "Decorated Component B: ";
    decoratedComponentB->operation();

    // 释放内存
    delete component;
    delete decoratedComponentA;
    delete decoratedComponentB;

    return 0;
}
```

在这个示例中，`Component` 是抽象组件，定义了对象的基本接口。`ConcreteComponent` 是具体组件，提供了基本的功能。`Decorator` 是抽象装饰器，实现了组件接口，并持有一个组件对象的引用。`ConcreteDecoratorA` 和 `ConcreteDecoratorB` 是具体装饰器，分别实现了装饰器的接口，并添加了额外的行为。在客户端中，创建具体组件和具体装饰器，并根据需要组合它们，从而实现了装饰器模式。

## 外观模式（Facade Pattern）

### 应用场景
外观模式适用于以下情况：
1. 当一个系统中存在复杂的子系统，并且客户端需要与这些子系统进行交互时，可以使用外观模式。外观模式可以将子系统的复杂性隐藏起来，提供一个简单的接口供客户端使用。
2. 当需要为一个复杂的子系统提供一个统一的入口点时，可以使用外观模式。外观模式可以封装子系统的接口，提供一个统一的接口供客户端访问，从而简化客户端的调用过程。

### 详细说明
外观模式是一种结构型设计模式，它提供了一个统一的接口，用于访问一个复杂子系统中的一组接口。外观模式主要包含三种角色：外观（Facade）、子系统（Subsystem）和客户端（Client）。
- 外观是客户端访问子系统的入口，它提供了一个简单的接口，隐藏了子系统的复杂性。
- 子系统是一个复杂的对象组成，它包含了多个不同的对象和接口。
- 客户端通过外观来访问子系统，而不需要了解子系统的具体实现。

### C++ 代码示例
以下是一个简单的外观模式的 C++ 代码示例：

```cpp
#include <iostream>

// 子系统A
class SubsystemA {
public:
    void operationA() const {
        std::cout << "Subsystem A operation" << std::endl;
    }
};

// 子系统B
class SubsystemB {
public:
    void operationB() const {
        std::cout << "Subsystem B operation" << std::endl;
    }
};

// 子系统C
class SubsystemC {
public:
    void operationC() const {
        std::cout << "Subsystem C operation" << std::endl;
    }
};

// 外观
class Facade {
private:
    SubsystemA* subsystemA_;
    SubsystemB* subsystemB_;
    SubsystemC* subsystemC_;

public:
    Facade() {
        subsystemA_ = new SubsystemA();
        subsystemB_ = new SubsystemB();
        subsystemC_ = new SubsystemC();
    }

    ~Facade() {
        delete subsystemA_;
        delete subsystemB_;
        delete subsystemC_;
    }

    // 提供一个简单的接口供客户端调用
    void operation() const {
        std::cout << "Facade: operation" << std::endl;
        subsystemA_->operationA();
        subsystemB_->operationB();
        subsystemC_->operationC();
    }
};

int main() {
    // 创建外观对象
    Facade* facade = new Facade();
    // 客户端通过外观对象调用子系统的操作
    facade->operation();
    // 释放内存
    delete facade;

    return 0;
}
```

在这个示例中，`SubsystemA`、`SubsystemB` 和 `SubsystemC` 是子系统的类，分别实现了子系统的不同功能。`Facade` 是外观类，提供了一个简单的接口供客户端调用，并在内部调用子系统的操作。在客户端中，创建外观对象，并通过外观对象调用子系统的操作，从而实现了外观模式。

## 享元模式（Flyweight Pattern）

### 应用场景
享元模式适用于以下情况：
1. 当一个系统中存在大量相似对象，且这些对象可以共享部分内部状态时，可以使用享元模式。享元模式可以通过共享内部状态来减少对象的数量，从而节省内存空间。
2. 当一个对象的多个实例之间共享相同的数据，但是数据的其他部分可能不同或者不需要共享时，可以使用享元模式。享元模式可以将对象的内部状态与外部状态分离，从而提高系统的灵活性。

### 详细说明
享元模式是一种结构型设计模式，它通过共享对象的部分状态来减少对象的数量，从而节省内存空间。享元模式主要包含两种角色：享元（Flyweight）和享元工厂（Flyweight Factory）。
- 享元是包含内部状态和外部状态的对象，内部状态是可共享的，而外部状态是不可共享的。
- 享元工厂用于创建和管理享元对象，它维护了一个享元对象的池，用于存储已创建的享元对象。

### C++ 代码示例
以下是一个简单的享元模式的 C++ 代码示例：

```cpp
#include <iostream>
#include <map>

// 抽象享元类
class Flyweight {
public:
    virtual void operation(int externalState) const = 0;
};

// 具体享元类
class ConcreteFlyweight : public Flyweight {
private:
    int intrinsicState_; // 内部状态

public:
    ConcreteFlyweight(int intrinsicState) : intrinsicState_(intrinsicState) {}

    void operation(int externalState) const override {
        std::cout << "Concrete Flyweight: Intrinsic State " << intrinsicState_
                  << ", External State " << externalState << std::endl;
    }
};

// 享元工厂类
class FlyweightFactory {
private:
    std::map<int, Flyweight*> flyweights_;

public:
    // 获取享元对象
    Flyweight* getFlyweight(int key) {
        if (flyweights_.find(key) != flyweights_.end()) {
            return flyweights_[key];
        } else {
            Flyweight* flyweight = new ConcreteFlyweight(key);
            flyweights_[key] = flyweight;
            return flyweight;
        }
    }

    // 获取享元对象的数量
    int getFlyweightsCount() const {
        return flyweights_.size();
    }
};

int main() {
    FlyweightFactory* factory = new FlyweightFactory();

    // 客户端使用享元对象
    Flyweight* flyweight1 = factory->getFlyweight(1);
    flyweight1->operation(100);

    Flyweight* flyweight2 = factory->getFlyweight(2);
    flyweight2->operation(200);

    Flyweight* flyweight3 = factory->getFlyweight(1); // 重复使用相同的享元对象
    flyweight3->operation(300);

    // 释放内存
    delete factory;

    return 0;
}
```

在这个示例中，`Flyweight` 是抽象享元类，定义了操作的接口。`ConcreteFlyweight` 是具体享元类，包含了内部状态。`FlyweightFactory` 是享元工厂类，用于创建和管理享元对象，它维护了一个享元对象的池。在客户端中，通过享元工厂来获取享元对象，并调用其操作方法。如果请求的享元对象已经存在，则直接返回已有的对象；否则创建一个新的享元对象并添加到享元对象池中。通过这种方式，可以节省内存空间并实现对象的共享。



# 行为型模式（Behavioral Patterns）

## 责任链模式（Chain of Responsibility Pattern）

责任链模式（Chain of Responsibility Pattern）是一种行为设计模式，其目的是将请求的发送者和接收者解耦，使多个对象都有机会处理请求。在责任链模式中，请求沿着一条链传递，直到有一个对象处理它为止。这种模式主要解决的是请求的发送者与接收者之间的耦合关系，让多个对象都有机会处理请求，避免了请求发送者需要明确知道处理请求的对象。

### 应用场景

责任链模式通常在以下情况下使用：

1. 有多个对象可以处理同一个请求，但不确定哪个对象会处理它。
2. 需要在不明确指定接收者的情况下，向多个对象中的一个发送请求。
3. 有多个对象可以处理请求，但客户端只需要知道请求被处理即可，不需要知道具体是哪个对象处理的。
4. 需要动态指定处理请求的对象集合。

### 详细说明

责任链模式由一系列处理请求的对象组成，每个对象都包含对下一个处理者的引用。当接收到请求时，对象会依次检查自己是否有能力处理请求，如果可以处理，则处理请求并停止传递；如果不能处理，则将请求传递给链中的下一个处理者。这种方式下，请求被发送者和接收者解耦，发送者不需要知道请求的处理细节，而只需要知道它会被处理。

### C++代码示例

下面是一个简单的 C++ 实现责任链模式的示例，假设有一个简单的报销系统，不同级别的领导可以处理不同额度的报销：

```cpp
#include <iostream>
#include <string>

// 请求类
class Request {
public:
    Request(int amount) : amount_(amount) {}
    int getAmount() const { return amount_; }
private:
    int amount_;
};

// 处理者基类
class Approver {
public:
    Approver(Approver* successor) : successor_(successor) {}
    virtual void processRequest(const Request& request) const = 0;
protected:
    Approver* successor_;
};

// 具体处理者类
class TeamLead : public Approver {
public:
    TeamLead(Approver* successor) : Approver(successor) {}
    void processRequest(const Request& request) const override {
        if (request.getAmount() <= 100) {
            std::cout << "TeamLead can approve reimbursement of $" << request.getAmount() << std::endl;
        } else if (successor_ != nullptr) {
            successor_->processRequest(request);
        }
    }
};

class Manager : public Approver {
public:
    Manager(Approver* successor) : Approver(successor) {}
    void processRequest(const Request& request) const override {
        if (request.getAmount() <= 500) {
            std::cout << "Manager can approve reimbursement of $" << request.getAmount() << std::endl;
        } else if (successor_ != nullptr) {
            successor_->processRequest(request);
        }
    }
};

class Director : public Approver {
public:
    Director(Approver* successor) : Approver(successor) {}
    void processRequest(const Request& request) const override {
        if (request.getAmount() <= 1000) {
            std::cout << "Director can approve reimbursement of $" << request.getAmount() << std::endl;
        } else {
            std::cout << "Amount is too large for Director to approve." << std::endl;
        }
    }
};

int main() {
    // 创建责任链
    Director director(nullptr);
    Manager manager(&director);
    TeamLead teamLead(&manager);

    // 创建请求
    Request request1(200);
    Request request2(700);
    Request request3(1500);

    // 处理请求
    teamLead.processRequest(request1);
    teamLead.processRequest(request2);
    teamLead.processRequest(request3);

    return 0;
}
```

在这个例子中，`Request` 类表示请求，`Approver` 是处理者基类，定义了一个纯虚函数 `processRequest` 来处理请求。`TeamLead`、`Manager` 和 `Director` 是具体的处理者类，分别代表小组长、经理和总监，它们都可以处理不同额度的报销请求。在 `main` 函数中，创建了责任链，并模拟了不同额度的报销请求的处理过程。

## 命令模式（Command Pattern）

命令模式（Command Pattern）是一种行为设计模式，它将请求封装成一个对象，从而允许使用不同的请求、队列或者日志请求来参数化其他对象。命令模式也支持可撤销的操作。

### 应用场景

命令模式通常在以下情况下使用：

1. **解耦请求发送者和接收者**：命令模式使得请求发送者和请求接收者之间解耦，发送者只需知道如何发送请求，而无需知道请求是如何被处理以及谁会处理它。

2. **支持撤销和重做**：通过将请求封装成对象，可以轻松地实现撤销和重做功能，因为可以保存命令历史。

3. **支持事务**：可以将一系列操作封装成一个命令，以确保它们要么全部执行成功，要么全部失败。

4. **日志记录**：可以使用命令模式记录操作日志，以便跟踪和审计系统中的操作。

### 详细说明

在命令模式中，有四个关键角色：

1. **Command（命令）**：声明执行操作的接口。
2. **ConcreteCommand（具体命令）**：实现 Command 接口，将一个接收者对象绑定于一个动作。
3. **Invoker（调用者）**：要求命令执行请求的对象。
4. **Receiver（接收者）**：知道如何实施与执行一个请求相关的操作。

命令模式的核心思想是将请求封装成对象，这些对象可以被参数化、传递，并且可以被放入队列中。这种设计允许请求的发送者和接收者能够独立变化，从而实现松耦合。

### C++代码示例

下面是一个简单的 C++ 实现命令模式的示例，假设有一个简单的电灯控制器，可以通过命令来控制电灯的开关：

```cpp
#include <iostream>
#include <string>

// Command Interface
class Command {
public:
    virtual void execute() const = 0;
};

// Receiver
class Light {
public:
    void turnOn() const {
        std::cout << "Light is on" << std::endl;
    }

    void turnOff() const {
        std::cout << "Light is off" << std::endl;
    }
};

// Concrete Commands
class TurnOnCommand : public Command {
public:
    TurnOnCommand(const Light& light) : light_(light) {}
    void execute() const override {
        light_.turnOn();
    }
private:
    const Light& light_;
};

class TurnOffCommand : public Command {
public:
    TurnOffCommand(const Light& light) : light_(light) {}
    void execute() const override {
        light_.turnOff();
    }
private:
    const Light& light_;
};

// Invoker
class RemoteControl {
public:
    void setCommand(Command* command) {
        command_ = command;
    }

    void pressButton() {
        command_->execute();
    }
private:
    Command* command_;
};

int main() {
    // 创建接收者
    Light light;

    // 创建具体命令
    TurnOnCommand turnOnCmd(light);
    TurnOffCommand turnOffCmd(light);

    // 创建调用者
    RemoteControl remote;

    // 设置命令并执行
    remote.setCommand(&turnOnCmd);
    remote.pressButton();

    remote.setCommand(&turnOffCmd);
    remote.pressButton();

    return 0;
}
```

在这个例子中，`Command` 是命令接口，定义了一个 `execute()` 方法。`TurnOnCommand` 和 `TurnOffCommand` 是具体命令类，实现了 `Command` 接口。`Light` 是接收者类，它包含了实际的操作。`RemoteControl` 是调用者类，它可以设置命令并执行命令。在 `main` 函数中，创建了命令对象和接收者对象，并将它们传递给调用者对象，然后执行命令。

## 解释器模式（Interpreter Pattern）

解释器模式（Interpreter Pattern）是一种行为设计模式，它定义了一种语言的文法，并且建立一个解释器来解释该语言中的句子。这种模式用于解决实际问题中的编程语言解释、正则表达式解析等问题。

### 应用场景

解释器模式通常在以下情况下使用：

1. **语言解释器**：需要解释执行特定语言的脚本、命令或表达式，如编程语言解释器、SQL 解释器等。
2. **正则表达式解析器**：需要解析和处理正则表达式的引擎。
3. **配置文件解析**：需要解析配置文件的结构，并根据配置文件执行相应的操作。
4. **数学表达式求值器**：需要解析数学表达式并计算结果。

### 详细说明

解释器模式由以下几个要素组成：

1. **抽象表达式（Abstract Expression）**：定义了一个抽象的解释操作，所有的具体表达式都需要实现这个接口。
2. **终结符表达式（Terminal Expression）**：实现了抽象表达式接口，代表语言中的终结符，不能再分解为更小的部分。
3. **非终结符表达式（Non-Terminal Expression）**：也实现了抽象表达式接口，代表语言中的非终结符，它包含了一个或多个终结符或非终结符。
4. **上下文环境（Context）**：包含解释器解释所需的全局信息。
5. **客户端（Client）**：构建、配置并解释表达式的对象。

解释器模式的核心思想是将一个语言解释成为另一种形式，通常是将一种语言转换为抽象语法树，然后通过遍历这个树来执行某种操作。

### C++代码示例

下面是一个简单的 C++ 实现解释器模式的示例，假设需要实现一个简单的四则运算解释器：

```cpp
#include <iostream>
#include <stack>
#include <string>

// 抽象表达式
class Expression {
public:
    virtual int interpret() const = 0;
};

// 终结符表达式
class NumberExpression : public Expression {
public:
    NumberExpression(int value) : value_(value) {}
    int interpret() const override {
        return value_;
    }
private:
    int value_;
};

// 非终结符表达式
class AddExpression : public Expression {
public:
    AddExpression(const Expression& left, const Expression& right)
        : left_(left), right_(right) {}
    int interpret() const override {
        return left_.interpret() + right_.interpret();
    }
private:
    const Expression& left_;
    const Expression& right_;
};

class SubtractExpression : public Expression {
public:
    SubtractExpression(const Expression& left, const Expression& right)
        : left_(left), right_(right) {}
    int interpret() const override {
        return left_.interpret() - right_.interpret();
    }
private:
    const Expression& left_;
    const Expression& right_;
};

// 客户端
int main() {
    // 构建语法树: 1 + (2 - 3)
    Expression* expression = new AddExpression(
        new NumberExpression(1),
        new SubtractExpression(
            new NumberExpression(2),
            new NumberExpression(3)
        )
    );

    // 执行解释器
    int result = expression->interpret();
    std::cout << "Result: " << result << std::endl;

    delete expression;
    return 0;
}
```

在这个例子中，`Expression` 是抽象表达式类，定义了一个纯虚函数 `interpret()`。`NumberExpression` 和 `AddExpression`、`SubtractExpression` 分别是终结符和非终结符表达式类。在 `main` 函数中，构建了一个简单的语法树，并执行解释器来计算结果。

## 迭代器模式（Iterator Pattern）

迭代器模式（Iterator Pattern）是一种行为设计模式，它提供一种方法来顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。迭代器模式使得访问一个聚合对象的元素变得简单而统一。

### 应用场景

迭代器模式通常在以下情况下使用：

1. **需要访问一个聚合对象的内容而不暴露其内部表示**：迭代器模式将访问聚合对象的任务委托给了迭代器，使得客户端代码不需要了解聚合对象的内部结构，从而增强了聚合对象的封装性。
2. **需要提供多种遍历方式**：迭代器模式可以定义多个不同的迭代器，用于实现不同的遍历方式，而客户端代码不需要更改。
3. **需要对聚合对象进行统一的遍历接口**：迭代器模式定义了统一的迭代接口，使得客户端代码可以通过统一的接口来遍历不同类型的聚合对象。

### 详细说明

迭代器模式由以下几个要素组成：

1. **迭代器接口（Iterator）**：定义了访问和遍历聚合对象元素的接口。
2. **具体迭代器（Concrete Iterator）**：实现了迭代器接口，对聚合对象进行具体的遍历操作。
3. **聚合对象接口（Aggregate）**：定义了创建迭代器的接口。
4. **具体聚合对象（Concrete Aggregate）**：实现了聚合对象接口，返回一个具体的迭代器。

迭代器模式的核心思想是将对集合元素的遍历操作从集合对象中分离出来，放到迭代器中进行，使得集合对象和遍历算法能够独立变化，互不影响。

### C++代码示例

下面是一个简单的 C++ 实现迭代器模式的示例，假设有一个简单的集合类 `Aggregate`，可以使用迭代器遍历其中的元素：

```cpp
#include <iostream>
#include <vector>

// 迭代器接口
class Iterator {
public:
    virtual int next() = 0;
    virtual bool hasNext() = 0;
};

// 具体迭代器
class ConcreteIterator : public Iterator {
public:
    ConcreteIterator(const std::vector<int>& collection)
        : collection_(collection), index_(0) {}

    int next() override {
        return collection_[index_++];
    }

    bool hasNext() override {
        return index_ < collection_.size();
    }

private:
    const std::vector<int>& collection_;
    int index_;
};

// 聚合对象接口
class Aggregate {
public:
    virtual Iterator* createIterator() = 0;
};

// 具体聚合对象
class ConcreteAggregate : public Aggregate {
public:
    ConcreteAggregate(std::vector<int> collection)
        : collection_(std::move(collection)) {}

    Iterator* createIterator() override {
        return new ConcreteIterator(collection_);
    }

private:
    std::vector<int> collection_;
};

// 客户端
int main() {
    std::vector<int> data = {1, 2, 3, 4, 5};
    Aggregate* aggregate = new ConcreteAggregate(data);
    Iterator* iterator = aggregate->createIterator();

    while (iterator->hasNext()) {
        std::cout << iterator->next() << " ";
    }
    std::cout << std::endl;

    delete aggregate;
    delete iterator;

    return 0;
}
```

在这个例子中，`Iterator` 是迭代器接口，定义了 `next()` 和 `hasNext()` 方法。`ConcreteIterator` 是具体的迭代器类，实现了 `Iterator` 接口。`Aggregate` 是聚合对象接口，定义了 `createIterator()` 方法。`ConcreteAggregate` 是具体的聚合对象类，实现了 `Aggregate` 接口。在 `main` 函数中，创建了一个聚合对象并使用迭代器遍历其中的元素。

## 中介者模式（Mediator Pattern）

中介者模式（Mediator Pattern）是一种行为设计模式，它用于减少对象之间的直接通信，而是通过一个中介对象来协调对象之间的交互。中介者模式封装了对象之间的交互，使得对象之间松耦合，从而更容易维护和扩展系统。

### 应用场景

中介者模式通常在以下情况下使用：

1. **多个对象之间存在复杂的交互**：当系统中的对象之间存在复杂的相互依赖关系和交互行为时，可以引入中介者模式来管理这些交互，减少对象之间的直接耦合。
2. **对象之间的通信产生大量的依赖关系**：如果对象之间的通信产生大量的依赖关系，会导致系统的耦合度较高，此时可以引入中介者模式来减少这些依赖关系，提高系统的灵活性和可维护性。
3. **业务逻辑中存在复杂的控制流程**：如果业务逻辑中存在复杂的控制流程，对象之间需要频繁地进行通信和协作，可以引入中介者模式来简化这些控制流程，使得系统更易于理解和维护。

### 详细说明

中介者模式由以下几个要素组成：

1. **中介者（Mediator）**：定义了一个接口用于与各个同事对象通信，并维护了各个同事对象之间的引用。
2. **具体中介者（Concrete Mediator）**：实现了中介者接口，负责协调各个同事对象之间的交互关系。
3. **同事对象（Colleague）**：定义了一个接口用于与中介者进行通信，并维护了一个指向中介者对象的引用。
4. **具体同事对象（Concrete Colleague）**：实现了同事接口，每个具体同事对象都知道自己的中介者对象，与其他同事对象通过中介者进行通信。

中介者模式的核心思想是通过引入一个中介者对象来封装一系列对象之间的交互行为，使得对象之间不需要直接相互通信，而是通过中介者对象进行通信，从而降低对象之间的耦合度，提高系统的可维护性和可扩展性。

### C++代码示例

下面是一个简单的 C++ 实现中介者模式的示例，假设有一个简单的聊天室系统，其中多个用户之间可以通过聊天室进行通信：

```cpp
#include <iostream>
#include <string>
#include <vector>

// 中介者接口
class Mediator {
public:
    virtual void sendMessage(const std::string& message, class Colleague* colleague) const = 0;
};

// 同事对象接口
class Colleague {
public:
    virtual void receiveMessage(const std::string& message) const = 0;
    virtual void sendMessage(const std::string& message) const = 0;
    virtual void setMediator(Mediator* mediator) = 0;
};

// 具体中介者
class ConcreteMediator : public Mediator {
public:
    void sendMessage(const std::string& message, Colleague* colleague) const override {
        for (auto& c : colleagues_) {
            if (c != colleague) {
                c->receiveMessage(message);
            }
        }
    }

    void addColleague(Colleague* colleague) {
        colleagues_.push_back(colleague);
    }

private:
    std::vector<Colleague*> colleagues_;
};

// 具体同事对象
class ConcreteColleague : public Colleague {
public:
    void receiveMessage(const std::string& message) const override {
        std::cout << "Received message: " << message << std::endl;
    }

    void sendMessage(const std::string& message) const override {
        mediator_->sendMessage(message, this);
    }

    void setMediator(Mediator* mediator) override {
        mediator_ = mediator;
    }

private:
    Mediator* mediator_;
};

int main() {
    ConcreteMediator mediator;
    ConcreteColleague colleague1, colleague2;

    colleague1.setMediator(&mediator);
    colleague2.setMediator(&mediator);

    mediator.addColleague(&colleague1);
    mediator.addColleague(&colleague2);

    colleague1.sendMessage("Hello, colleague2!");
    colleague2.sendMessage("Hi, colleague1!");

    return 0;
}
```

在这个例子中，`Mediator` 是中介者接口，定义了一个 `sendMessage()` 方法用于发送消息。`Colleague` 是同事对象接口，定义了一个 `receiveMessage()` 方法用于接收消息，一个 `sendMessage()` 方法用于发送消息，以及一个 `setMediator()` 方法用于设置中介者对象。`ConcreteMediator` 是具体中介者类，实现了 `Mediator` 接口，负责协调各个同事对象之间的通信。`ConcreteColleague` 是具体同事对象类，实现了 `Colleague` 接口，每个具体同事对象都知道自己的中介者对象，并通过中介者对象进行通信。在 `main` 函数中，创建了一个中介者对象和两个具体同事对象，然后通过中介者对象进行通信。

## 备忘录模式（Memento Pattern）

备忘录模式（Memento Pattern）是一种行为设计模式，用于捕获对象的内部状态并在不破坏对象封装性的情况下将其保存，以便稍后可以将对象恢复到之前的状态。备忘录模式允许在不暴露对象内部细节的情况下实现对象状态的保存和恢复。

### 应用场景

备忘录模式通常在以下情况下使用：

1. **需要实现对象状态的撤销和重做功能**：备忘录模式允许在不破坏对象封装性的情况下保存和恢复对象的状态，可以用于实现对象状态的撤销和重做功能。
2. **需要保存对象状态的快照**：备忘录模式允许将对象的内部状态保存到备忘录对象中，以便稍后可以将对象恢复到之前的状态。
3. **需要实现对象状态的历史记录功能**：备忘录模式可以用于实现对象状态的历史记录功能，以便跟踪对象状态的变化。

### 详细说明

备忘录模式由以下几个要素组成：

1. **备忘录（Memento）**：负责存储对象的内部状态，并可以防止对象之外的其他对象访问备忘录的内部状态。
2. **原发器（Originator）**：负责创建备忘录，并在需要时将自身状态恢复到备忘录所记录的状态。
3. **负责人（Caretaker）**：负责保存备忘录，并在需要时将备忘录提供给原发器以便恢复状态。

备忘录模式的核心思想是通过将对象的状态保存到备忘录对象中，从而使得对象的状态可以随时被恢复到之前的状态，而不需要暴露对象的内部细节。

### C++代码示例

下面是一个简单的 C++ 实现备忘录模式的示例，假设有一个简单的文本编辑器，可以撤销和重做文本的编辑操作：

```cpp
#include <iostream>
#include <string>
#include <vector>

// 备忘录
class Memento {
public:
    Memento(const std::string& state) : state_(state) {}
    const std::string& getState() const {
        return state_;
    }
private:
    std::string state_;
};

// 原发器
class Editor {
public:
    void setState(const std::string& state) {
        state_ = state;
    }

    std::string getState() const {
        return state_;
    }

    Memento* createMemento() {
        return new Memento(state_);
    }

    void restoreFromMemento(const Memento* memento) {
        state_ = memento->getState();
    }

private:
    std::string state_;
};

// 负责人
class History {
public:
    void addMemento(Memento* memento) {
        mementos_.push_back(memento);
    }

    Memento* getMemento(size_t index) const {
        if (index < mementos_.size()) {
            return mementos_[index];
        }
        return nullptr;
    }

private:
    std::vector<Memento*> mementos_;
};

int main() {
    Editor editor;
    History history;

    // 编辑文本
    editor.setState("Hello");
    history.addMemento(editor.createMemento());

    editor.setState("Hello World");
    history.addMemento(editor.createMemento());

    editor.setState("Hello World!");
    history.addMemento(editor.createMemento());

    // 恢复到之前的状态
    editor.restoreFromMemento(history.getMemento(1));
    std::cout << "Current state: " << editor.getState() << std::endl;

    return 0;
}
```

在这个例子中，`Memento` 是备忘录类，负责存储对象的内部状态。`Editor` 是原发器类，负责创建备忘录并在需要时将自身状态恢复到备忘录所记录的状态。`History` 是负责人类，负责保存备忘录，并在需要时将备忘录提供给原发器以便恢复状态。在 `main` 函数中，创建了一个文本编辑器对象和一个历史记录对象，可以撤销和重做文本的编辑操作。

## 观察者模式（Observer Pattern）

观察者模式（Observer Pattern）是一种行为设计模式，它定义了一种一对多的依赖关系，使得当一个对象的状态发生变化时，所有依赖于它的对象都会自动收到通知并更新。观察者模式可以实现对象之间的松耦合，使得对象之间的关系更加灵活。

### 应用场景

观察者模式通常在以下情况下使用：

1. **对象间存在一对多的依赖关系**：当一个对象的状态发生变化时，需要通知多个其他对象进行相应的处理。
2. **对象的状态变化需要通知其他对象进行更新**：当一个对象的状态发生变化时，需要通知其他对象进行相应的更新操作，而不是手动去通知每一个依赖对象。
3. **解耦合关系**：观察者模式可以将观察者与被观察者解耦合，使得它们可以独立变化而不相互影响。

### 详细说明

观察者模式由以下几个要素组成：

1. **被观察者（Subject）**：也称为主题或可观察对象，负责维护一组观察者，并在自身状态发生变化时通知观察者。
2. **观察者（Observer）**：也称为订阅者或监听者，负责接收被观察者发送的通知，并进行相应的更新操作。
3. **具体被观察者（Concrete Subject）**：实现被观察者接口，负责维护一组观察者，并在自身状态发生变化时通知观察者。
4. **具体观察者（Concrete Observer）**：实现观察者接口，负责接收被观察者发送的通知，并进行相应的更新操作。

观察者模式的核心思想是定义一个一对多的依赖关系，当被观察者的状态发生变化时，通知所有依赖于它的观察者进行更新。

### C++代码示例

下面是一个简单的 C++ 实现观察者模式的示例，假设有一个简单的主题（被观察者）和两个观察者，当主题的状态发生变化时，通知所有的观察者进行更新：

```cpp
#include <iostream>
#include <vector>

// 观察者接口
class Observer {
public:
    virtual void update(const std::string& message) = 0;
};

// 主题接口
class Subject {
public:
    virtual void attach(Observer* observer) = 0;
    virtual void detach(Observer* observer) = 0;
    virtual void notify(const std::string& message) = 0;
};

// 具体观察者
class ConcreteObserver : public Observer {
public:
    ConcreteObserver(const std::string& name) : name_(name) {}
    void update(const std::string& message) override {
        std::cout << name_ << " received message: " << message << std::endl;
    }
private:
    std::string name_;
};

// 具体主题
class ConcreteSubject : public Subject {
public:
    void attach(Observer* observer) override {
        observers_.push_back(observer);
    }

    void detach(Observer* observer) override {
        for (auto it = observers_.begin(); it != observers_.end(); ++it) {
            if (*it == observer) {
                observers_.erase(it);
                break;
            }
        }
    }

    void notify(const std::string& message) override {
        for (auto observer : observers_) {
            observer->update(message);
        }
    }

private:
    std::vector<Observer*> observers_;
};

int main() {
    ConcreteSubject subject;

    ConcreteObserver observer1("Observer1");
    ConcreteObserver observer2("Observer2");

    subject.attach(&observer1);
    subject.attach(&observer2);

    subject.notify("Hello, observers!");

    return 0;
}
```

在这个例子中，`Observer` 是观察者接口，定义了一个 `update()` 方法用于接收被观察者发送的通知。`Subject` 是主题接口，定义了 `attach()`、`detach()` 和 `notify()` 方法用于管理观察者，并在自身状态发生变化时通知观察者。`ConcreteObserver` 是具体观察者类，实现了 `Observer` 接口。`ConcreteSubject` 是具体主题类，实现了 `Subject` 接口。在 `main` 函数中，创建了一个主题对象和两个观察者对象，并将观察者对象注册到主题对象中，当主题的状态发生变化时，通知所有的观察者进行更新。

## 状态模式（State Pattern）

状态模式（State Pattern）是一种行为型设计模式，用于实现对象在不同状态下的行为变化。它将对象的状态封装成独立的类，并且允许对象在运行时根据其内部状态的改变而改变其行为。状态模式的核心思想是将对象的行为封装成不同的状态类，从而使得对象的行为可以随着状态的变化而变化，同时也使得状态之间的转换变得简单而灵活。

### 应用场景

1. **状态机**：当对象的行为在不同状态下有不同的行为时，可以使用状态模式来实现状态机。
2. **订单处理系统**：订单可能有不同的状态（已创建、已支付、已发货、已完成等），每种状态下订单的行为都不同，可以使用状态模式来管理订单的状态。
3. **游戏中的角色状态**：例如游戏中的角色可能有正常状态、受伤状态、死亡状态等，每种状态下角色的行为都不同。
4. **多媒体播放器**：多媒体播放器可能有播放状态、暂停状态、停止状态等，可以使用状态模式来管理播放器的状态。

### 详细说明

状态模式由三个主要角色组成：

1. **Context（上下文）**：维护一个当前状态的引用，并且将客户端的请求委托给当前状态对象处理。
2. **State（状态）**：定义一个接口，用于封装与Context相关的一个状态的行为。
3. **ConcreteState（具体状态）**：实现State接口，每一个具体状态类都实现了Context对象在该状态下的行为。

使用状态模式的关键是将对象的状态封装成独立的类，从而使得状态之间的转换变得简单而灵活。同时，状态模式遵循了开闭原则，当需要增加新的状态时，只需要添加新的具体状态类即可，而不需要修改已有的代码。

### C++代码示例

下面是一个简单的使用状态模式的 C++ 代码示例，模拟一个简单的灯泡状态管理系统：

```cpp
#include <iostream>

// 定义状态接口
class State {
public:
    virtual void turnOn() = 0;
    virtual void turnOff() = 0;
};

// 具体状态类：关闭状态
class OffState : public State {
public:
    void turnOn() override;
    void turnOff() override {
        std::cout << "The light is already off." << std::endl;
    }
};

// 具体状态类：打开状态
class OnState : public State {
public:
    void turnOn() override {
        std::cout << "The light is already on." << std::endl;
    }
    void turnOff() override;
};

// 上下文类：灯泡
class Light {
private:
    State *currentState;

public:
    Light() {
        currentState = new OffState(); // 初始状态为关闭状态
    }

    void setState(State *state) {
        currentState = state;
    }

    void turnOn() {
        currentState->turnOn();
    }

    void turnOff() {
        currentState->turnOff();
    }
};

// 实现具体状态类中的方法
void OffState::turnOn() {
    std::cout << "Turning on the light." << std::endl;
    // 切换状态
    Light *light = new Light();
    light->setState(new OnState());
    delete this; // 删除当前状态
}

void OnState::turnOff() {
    std::cout << "Turning off the light." << std::endl;
    // 切换状态
    Light *light = new Light();
    light->setState(new OffState());
    delete this; // 删除当前状态
}

int main() {
    Light light;
    light.turnOn();
    light.turnOff();
    light.turnOff();
    light.turnOn();

    return 0;
}
```

在上面的示例中，`Light` 类表示灯泡，有两种状态：打开和关闭。`State` 是状态的抽象类，包含了两个虚函数 `turnOn` 和 `turnOff`，表示打开和关闭。`OffState` 和 `OnState` 分别表示灯泡关闭和打开的状态，实现了 `State` 接口中的方法。在 `Light` 类中，根据当前状态执行相应的操作。当需要改变灯泡的状态时，会动态地切换状态。

## 策略模式（Strategy Pattern）

策略模式（Strategy Pattern）是一种行为型设计模式，它允许在运行时选择算法的行为。该模式定义了一系列的算法，将每个算法封装起来，并使它们可以相互替换。策略模式使得算法的变化独立于使用算法的客户端。

### 应用场景

1. **排序算法**：不同的排序算法（如快速排序、归并排序、插入排序等）可以作为不同的策略，根据具体需求选择合适的算法。
2. **数据压缩**：不同的压缩算法（如ZIP、RAR、GZIP等）可以作为不同的策略，根据文件类型或性能要求选择合适的压缩算法。
3. **支付方式**：不同的支付方式（如信用卡支付、支付宝、微信支付等）可以作为不同的策略，根据用户的选择来使用不同的支付方式。
4. **图像处理**：不同的图像处理算法（如旋转、缩放、滤镜等）可以作为不同的策略，根据用户需求或图像特性选择合适的处理算法。

### 详细说明

策略模式由三个主要角色组成：

1. **Context（上下文）**：维护一个对策略对象的引用，并且负责将客户端的请求委派给策略对象来处理。
2. **Strategy（策略）**：定义一个接口，用于封装算法的行为。
3. **ConcreteStrategy（具体策略）**：实现Strategy接口，每一个具体策略类都实现了具体的算法。

策略模式通过将不同的算法封装成独立的策略类，使得算法可以在不影响客户端的情况下独立变化。通过在运行时动态地切换不同的策略，客户端可以选择不同的算法来满足特定的需求。

### C++代码示例

下面是一个简单的使用策略模式的 C++ 代码示例，模拟一个简单的排序算法选择器：

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

// 策略接口
class SortingStrategy {
public:
    virtual void sort(std::vector<int>& data) = 0;
};

// 具体策略类：快速排序
class QuickSortStrategy : public SortingStrategy {
public:
    void sort(std::vector<int>& data) override {
        std::cout << "Using Quick Sort" << std::endl;
        std::sort(data.begin(), data.end());
    }
};

// 具体策略类：归并排序
class MergeSortStrategy : public SortingStrategy {
public:
    void sort(std::vector<int>& data) override {
        std::cout << "Using Merge Sort" << std::endl;
        // 实现归并排序
    }
};

// 上下文类：排序选择器
class SortSelector {
private:
    SortingStrategy* strategy;

public:
    SortSelector(SortingStrategy* strategy) : strategy(strategy) {}

    void setStrategy(SortingStrategy* newStrategy) {
        strategy = newStrategy;
    }

    void performSort(std::vector<int>& data) {
        strategy->sort(data);
    }
};

int main() {
    std::vector<int> data = {5, 2, 7, 1, 9};

    SortSelector selector(new QuickSortStrategy());
    selector.performSort(data); // 使用快速排序

    selector.setStrategy(new MergeSortStrategy());
    selector.performSort(data); // 使用归并排序

    return 0;
}
```

在上面的示例中，`SortingStrategy` 是策略接口，定义了 `sort` 方法用于排序。`QuickSortStrategy` 和 `MergeSortStrategy` 分别是快速排序和归并排序的具体策略类，实现了 `SortingStrategy` 接口中的 `sort` 方法。`SortSelector` 是上下文类，负责维护对策略对象的引用，并且负责将客户端的请求委派给策略对象来处理。在 `main` 函数中，根据需要选择不同的排序策略来对数据进行排序。

## 模板方法模式（Template Method Pattern）

模板方法模式（Template Method Pattern）是一种行为型设计模式，用于定义算法的框架，将算法的具体步骤延迟到子类中。模板方法模式通过定义一个算法的骨架，将算法中的具体步骤延迟到子类中实现，从而使得子类可以在不改变算法结构的情况下重新定义算法的某些步骤。

### 应用场景

1. **软件开发流程**：软件开发过程中的需求分析、设计、编码、测试等阶段可以使用模板方法模式，其中整个开发流程是一个框架，具体的开发步骤由不同的子类实现。
2. **游戏开发**：游戏中的角色创建、AI行为等可以使用模板方法模式，其中角色创建和AI行为是一个框架，具体的角色属性和行为由子类实现。
3. **咖啡与茶的制作**：制作咖啡和茶的过程中，烧水、冲泡、加料等步骤可以使用模板方法模式，其中烧水和冲泡是一个框架，具体的饮品和加料由子类实现。

### 详细说明

模板方法模式由两个主要角色组成：

1. **AbstractClass（抽象类）**：定义算法的框架，其中包含了一个或多个抽象方法，用于延迟到子类实现。
2. **ConcreteClass（具体类）**：实现抽象类中的抽象方法，完成算法的具体步骤。

在模板方法模式中，抽象类中定义了算法的骨架，其中的具体步骤通过抽象方法来延迟到子类中实现。子类可以根据需要来重写或实现这些抽象方法，从而定制算法的具体步骤，但是算法的框架结构是固定的，无法修改。

模板方法模式提供了一种在不改变算法结构的情况下重新定义算法的某些步骤的方法，同时也遵循了开闭原则，使得算法的框架可以复用，具体步骤可以灵活变化。

### C++代码示例

下面是一个简单的使用模板方法模式的 C++ 代码示例，模拟一个制作饮品的过程：

```cpp
#include <iostream>

// 抽象类：饮品
class Beverage {
public:
    // 模板方法，制作饮品
    void makeBeverage() {
        boilWater(); // 烧水
        brew();      // 冲泡
        pourInCup(); // 倒入杯中
        if (customerWantsCondiments()) { // 钩子方法
            addCondiments(); // 加入调料
        }
    }

    // 抽象方法，烧水
    virtual void boilWater() {
        std::cout << "Boiling water" << std::endl;
    }

    // 抽象方法，冲泡
    virtual void brew() = 0;

    // 抽象方法，倒入杯中
    virtual void pourInCup() {
        std::cout << "Pouring into cup" << std::endl;
    }

    // 抽象方法，加入调料
    virtual void addCondiments() = 0;

    // 钩子方法，用于控制是否加入调料，默认返回true
    virtual bool customerWantsCondiments() {
        return true;
    }
};

// 具体类：咖啡
class Coffee : public Beverage {
public:
    // 实现冲泡方法
    void brew() override {
        std::cout << "Dripping coffee through filter" << std::endl;
    }

    // 实现加入调料方法
    void addCondiments() override {
        std::cout << "Adding sugar and milk" << std::endl;
    }
};

// 具体类：茶
class Tea : public Beverage {
public:
    // 实现冲泡方法
    void brew() override {
        std::cout << "Steeping the tea" << std::endl;
    }

    // 实现加入调料方法
    void addCondiments() override {
        std::cout << "Adding lemon" << std::endl;
    }

    // 重写钩子方法，不加调料
    bool customerWantsCondiments() override {
        return false;
    }
};

int main() {
    Beverage* coffee = new Coffee();
    coffee->makeBeverage();
    delete coffee;

    std::cout << std::endl;

    Beverage* tea = new Tea();
    tea->makeBeverage();
    delete tea;

    return 0;
}
```

在上面的示例中，`Beverage` 是抽象类，定义了制作饮品的框架，其中包含了模板方法 `makeBeverage` 和一些抽象方法。`Coffee` 和 `Tea` 是具体类，分别实现了抽象类中的抽象方法，完成了制作咖啡和茶的具体步骤。在 `main` 函数中，通过创建不同的具体类对象来制作不同的饮品。

## 访问者模式（Visitor Pattern）

访问者模式（Visitor Pattern）是一种行为型设计模式，用于在不改变对象结构的情况下定义对对象的新操作。该模式将数据结构与操作分离开来，使得可以在不修改数据结构的前提下增加新的操作。访问者模式通过在数据结构中引入访问者对象，使得可以在不改变数据结构的情况下定义新的操作。

### 应用场景

1. **编译器设计**：编译器可以使用访问者模式来遍历抽象语法树（AST），执行语法分析、语义分析、优化等操作。
2. **文件系统操作**：文件系统可以使用访问者模式来遍历目录树，执行文件搜索、文件统计、文件压缩等操作。
3. **数据结构操作**：数据结构如树、图等可以使用访问者模式来执行遍历操作，进行统计、搜索、转换等操作。
4. **GUI组件操作**：GUI组件库中的组件可以使用访问者模式来处理不同的事件，如鼠标点击事件、键盘输入事件等。

### 详细说明

访问者模式由两个主要角色组成：

1. **Visitor（访问者）**：定义了对数据结构中每个元素的访问操作。在访问者模式中，每个具体的访问者类都实现了对数据结构中不同元素的访问操作。
2. **Element（元素）**：定义了接受访问者对象的接口，以便访问者可以访问到该元素。在访问者模式中，每个具体的元素类都实现了接受访问者对象的方法。
3. **ConcreteElement（具体元素）**：实现了元素接口，负责具体的业务逻辑。在访问者模式中，每个具体元素类都实现了接受访问者对象的方法。
4. **ObjectStructure（对象结构）**：维护一个元素的集合，并且提供一个接受访问者对象的方法，用于遍历元素集合。

访问者模式通过引入访问者对象，使得可以在不改变数据结构的情况下定义新的操作。访问者模式将操作与数据结构分离开来，使得操作可以独立变化，同时也符合单一职责原则。

### C++代码示例

下面是一个简单的使用访问者模式的 C++ 代码示例，模拟一个文件系统的访问者模式：

```cpp
#include <iostream>
#include <vector>

// Forward declarations
class File;
class Directory;
class Visitor;

// Element interface
class Element {
public:
    virtual void accept(Visitor* visitor) = 0;
};

// Concrete elements
class File : public Element {
public:
    void accept(Visitor* visitor) override {
        visitor->visit(this);
    }
};

class Directory : public Element {
private:
    std::vector<Element*> children;

public:
    void addChild(Element* element) {
        children.push_back(element);
    }

    void accept(Visitor* visitor) override {
        visitor->visit(this);
        for (Element* child : children) {
            child->accept(visitor);
        }
    }
};

// Visitor interface
class Visitor {
public:
    virtual void visit(File* file) = 0;
    virtual void visit(Directory* directory) = 0;
};

// Concrete visitor
class FileSearchVisitor : public Visitor {
public:
    void visit(File* file) override {
        // Process file
    }

    void visit(Directory* directory) override {
        // Process directory
    }
};

int main() {
    Directory root;
    File file1, file2;
    Directory subDir;

    root.addChild(&file1);
    root.addChild(&subDir);
    subDir.addChild(&file2);

    FileSearchVisitor visitor;
    root.accept(&visitor);

    return 0;
}
```

在上面的示例中，`Element` 是元素接口，定义了接受访问者对象的方法 `accept`。`File` 和 `Directory` 是具体元素类，实现了元素接口中的 `accept` 方法，并且可以接受访问者对象。`Visitor` 是访问者接口，定义了对不同元素的访问操作。`FileSearchVisitor` 是具体访问者类，实现了访问者接口中的访问方法。在 `main` 函数中，创建了一个文件系统的对象结构，并且创建了一个具体的访问者对象来对文件系统进行访问。